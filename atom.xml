<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[始终]]></title>
  <subtitle><![CDATA[不忘初心]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liam0205.me/"/>
  <updated>2015-07-03T05:38:00.620Z</updated>
  <id>http://liam0205.me/</id>
  
  <author>
    <name><![CDATA[Liam Huang]]></name>
    <email><![CDATA[liamhuang0205+blog@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[在 LaTeX 的 book 类中实现章节间空白页「This page is intetionally left blank」的效果]]></title>
    <link href="http://liam0205.me/2015/07/03/cleardoublepage-this-page-is-intentionally-left-blank/"/>
    <id>http://liam0205.me/2015/07/03/cleardoublepage-this-page-is-intentionally-left-blank/</id>
    <published>2015-07-03T05:16:32.000Z</published>
    <updated>2015-07-03T05:37:52.000Z</updated>
    <content type="html"><![CDATA[<p>很多书籍在设计版式的时候，会要求 <code>\chapter</code> 从奇数页码开始：上一章节在奇数页结束则留白一页，而后再从奇数页码继续排版。为了避免给读者造成「这里的内容缺失了」的印象，通常会写上「This page is intetionally left blank」的字样。</p>
<p>本文来实现这种效果。</p>
<a id="more"></a>

<p>LaTeX 的 <code>book</code> 文档类实现章首页从奇数页码开始，是借助 <code>\cleardoublepage</code> 命令实现的。原始的 <code>\cleardoublepage</code> 命令首先会调用 <code>\clearpage</code> 结束当前页，然后会检查页码状态：</p>
<ul>
<li>如果是奇数页码，那么什么也不做，直接开始排版</li>
<li>如果是偶数页码，则再一次另起一页，从下一页开始排版</li>
</ul>
<p>我们可以在 <code>source2e.pdf</code> 中找到这一定义：</p>
<p><img src="/images/LaTeX/def-of-cleardoublepage.png" alt="LaTeX2e 内核中 \cleardoublepage 的定义 "></p>
<p>我们只需要修改这一定义即可。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">[</span>UTF8<span class="special">]</span><span class="special">{</span>ctexbook<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>tikz<span class="special">}</span>
<span class="command">\makeatletter</span>
<span class="command">\renewcommand</span><span class="special">{</span><span class="command">\cleardoublepage</span><span class="special">}</span><span class="special">{</span><span class="command">\relax</span>
  <span class="command">\clearpage</span>
  <span class="command">\if</span>@twoside <span class="command">\ifodd</span><span class="command">\c</span>@page<span class="command">\relax</span><span class="command">\else</span>
  <span class="command">\thispagestyle</span><span class="special">{</span>empty<span class="special">}</span><span class="comment">%</span>
  <span class="command">\tikz</span><span class="special">[</span>remember picture, overlay<span class="special">]</span> <span class="command">\node</span>  at (current page.center)
    <span class="special">{</span><span class="command">\large</span> 广告位招租<span class="special">}</span>;<span class="command">\newpage</span><span class="command">\fi</span><span class="command">\fi</span><span class="special">}</span>
<span class="command">\makeatother</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\chapter</span><span class="special">{</span>测试<span class="special">}</span>
<span class="command">\chapter</span><span class="special">{</span>测试<span class="special">}</span>
<span class="command">\clearpage</span>
测试
<span class="command">\chapter</span><span class="special">{</span>测试<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>在这里，我们重定义了 <code>\cleardoublepage</code> 命令：</p>
<ul>
<li>用 <code>\clearpage</code> 结束当前页</li>
<li>检测文档类模式，如果是双面模式，则继续检测，反之则结束操作</li>
<li>继续检测当前页码，当前页码是奇数，则继续排版，反之则将当前页面风格设置为 <code>empty</code> 并用 TikZ 在页面中心写下「广告位招租」几个字</li>
</ul>
<p><img src="/images/LaTeX/intentionlly-left-blank.png" alt=" 实际效果 "></p>
<p>注意，需要编译两遍才能得到正确的结果。</p>
]]></content>
    <summary type="html"><![CDATA[<p>很多书籍在设计版式的时候，会要求 <code>\chapter</code> 从奇数页码开始：上一章节在奇数页结束则留白一页，而后再从奇数页码继续排版。为了避免给读者造成「这里的内容缺失了」的印象，通常会写上「This page is intetionally left blank」的字样。</p>
<p>本文来实现这种效果。</p>
]]></summary>
    
      <category term="Cleardoublepage" scheme="http://liam0205.me/tags/Cleardoublepage/"/>
    
      <category term="Chapter" scheme="http://liam0205.me/tags/Chapter/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[升级 Ubuntu，解决登录时提示有软件包可以更新的问题]]></title>
    <link href="http://liam0205.me/2015/06/27/ubuntu-server-packages-can-be-updated/"/>
    <id>http://liam0205.me/2015/06/27/ubuntu-server-packages-can-be-updated/</id>
    <published>2015-06-27T01:25:25.000Z</published>
    <updated>2015-06-27T02:42:52.000Z</updated>
    <content type="html"><![CDATA[<p>Ubuntu 系统在用户登录时会显示欢迎信息。有时用户会看到「有 xx 个软件包可以更新，其中有 xx 个安全更新」。</p>
<pre><code>Welcome <span class="built_in">to</span> Ubuntu <span class="number">14.04</span><span class="number">.2</span> LTS (GNU/Linux <span class="number">3.13</span><span class="number">.0</span>-<span class="number">48</span>-generic x86_64)

 * Documentation:  <span class="keyword">https</span>://help.ubuntu.com/

  System information <span class="keyword">as</span> <span class="operator">of</span> Sat Jun <span class="number">27</span> <span class="number">01</span>:<span class="number">12</span>:<span class="number">04</span> UTC <span class="number">2015</span>

  System <span class="built_in">load</span>:  <span class="number">0.0</span>               Processes:           <span class="number">98</span>
  Usage <span class="operator">of</span> /:   <span class="number">10.6</span>% <span class="operator">of</span> <span class="number">9.71</span>GB   Users logged <span class="operator">in</span>:     <span class="number">0</span>
  Memory usage: <span class="number">10</span>%               IP address <span class="keyword">for</span> eth0: <span class="number">192.168</span><span class="number">.12</span><span class="number">.233</span>
  Swap usage:   <span class="number">0</span>%

  Graph this data <span class="operator">and</span> manage this <span class="keyword">system</span> <span class="keyword">at</span>:
    <span class="keyword">https</span>://landscape.canonical.com/

  Get cloud support <span class="operator">with</span> Ubuntu Advantage Cloud Guest:
    <span class="keyword">http</span>://www.ubuntu.com/business/services/cloud

<span class="number">91</span> packages can be updated.
<span class="number">39</span> updates are security updates.
</code></pre><p>对于一般的更新，如果不影响使用，一般也就罢了。但是通常，如果系统提示有安全更新，大多数用户（特别是服务器管理员）还是会去更新的。不过，面对 Ubuntu 的这些提示，很多用户经常遇到「不管怎么 <code>apt-get updage &amp;&amp; apt-get upgrade</code> 也不见好」的问题。</p>
<a id="more"></a>

<h2 id=" 升级命令 ">升级命令</h2>
<p>虽然 apt-get 经常被人诟病，但实际上它还是个挺好用的软件包管理器。在 Ubuntu 14.04 以后的系统中，apt-get 相关的升级更新命令有四个：</p>
<pre><code>apt<span class="attribute">-get</span> update
apt<span class="attribute">-get</span> upgrade
apt<span class="attribute">-get</span> <span class="literal">full</span><span class="attribute">-upgrade</span>
apt<span class="attribute">-get</span> dist<span class="attribute">-upgrade</span>
</code></pre><p>那么，这四个升级命令都有什么差别呢？</p>
<p>根据 apt-get 的官方手册：</p>
<ul>
<li><code>update</code> - 从服务器更新可用的软件包列表。</li>
<li><code>upgrade</code> - 根据列表，更新已安装的软件包。<code>upgrade</code> 不会删除在列表中已经没有的软件包，也不会安装有依赖需求但尚未安装的软件包。</li>
<li><code>full-upgrade</code> - 根据列表，更新已安装的软件包。<code>full-upgrade</code> 可能会为了解决软件包冲突而删除一些已安装的软件包。</li>
<li><code>dist-upgrade</code> - 根据列表，更新已安装的软件包。<code>dist-upgrade</code> 可能会为了解决软件包冲突而删除一些已安装的软件包，也可能会为了解决软件包依赖问题安装新的软件包。</li>
</ul>
<h2 id=" 我们应该怎么做？">我们应该怎么做？</h2>
<p>依次执行如下命令即可：</p>
<pre><code><span class="built_in">sudo</span> apt-get update
<span class="built_in">sudo</span> apt-get upgrade
<span class="built_in">sudo</span> apt-get dist-upgrade
<span class="built_in">sudo</span> reboot
</code></pre>]]></content>
    <summary type="html"><![CDATA[<p>Ubuntu 系统在用户登录时会显示欢迎信息。有时用户会看到「有 xx 个软件包可以更新，其中有 xx 个安全更新」。</p>
<pre><code>Welcome <span class="built_in">to</span> Ubuntu <span class="number">14.04</span><span class="number">.2</span> LTS (GNU/Linux <span class="number">3.13</span><span class="number">.0</span>-<span class="number">48</span>-generic x86_64)

 * Documentation:  <span class="keyword">https</span>://help.ubuntu.com/

  System information <span class="keyword">as</span> <span class="operator">of</span> Sat Jun <span class="number">27</span> <span class="number">01</span>:<span class="number">12</span>:<span class="number">04</span> UTC <span class="number">2015</span>

  System <span class="built_in">load</span>:  <span class="number">0.0</span>               Processes:           <span class="number">98</span>
  Usage <span class="operator">of</span> /:   <span class="number">10.6</span>% <span class="operator">of</span> <span class="number">9.71</span>GB   Users logged <span class="operator">in</span>:     <span class="number">0</span>
  Memory usage: <span class="number">10</span>%               IP address <span class="keyword">for</span> eth0: <span class="number">192.168</span><span class="number">.12</span><span class="number">.233</span>
  Swap usage:   <span class="number">0</span>%

  Graph this data <span class="operator">and</span> manage this <span class="keyword">system</span> <span class="keyword">at</span>:
    <span class="keyword">https</span>://landscape.canonical.com/

  Get cloud support <span class="operator">with</span> Ubuntu Advantage Cloud Guest:
    <span class="keyword">http</span>://www.ubuntu.com/business/services/cloud

<span class="number">91</span> packages can be updated.
<span class="number">39</span> updates are security updates.
</code></pre><p>对于一般的更新，如果不影响使用，一般也就罢了。但是通常，如果系统提示有安全更新，大多数用户（特别是服务器管理员）还是会去更新的。不过，面对 Ubuntu 的这些提示，很多用户经常遇到「不管怎么 <code>apt-get updage &amp;&amp; apt-get upgrade</code> 也不见好」的问题。</p>
]]></summary>
    
      <category term="Ubuntu" scheme="http://liam0205.me/tags/Ubuntu/"/>
    
      <category term="Server" scheme="http://liam0205.me/tags/Server/"/>
    
      <category term="Update" scheme="http://liam0205.me/tags/Update/"/>
    
      <category term="apt-get" scheme="http://liam0205.me/tags/apt-get/"/>
    
      <category term="Upgrade" scheme="http://liam0205.me/tags/Upgrade/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 TeX Live 测试期间跨版本更新宏包]]></title>
    <link href="http://liam0205.me/2015/06/02/fake-tlpretest-to-update-packages/"/>
    <id>http://liam0205.me/2015/06/02/fake-tlpretest-to-update-packages/</id>
    <published>2015-06-02T03:36:32.000Z</published>
    <updated>2015-06-02T04:24:30.000Z</updated>
    <content type="html"><![CDATA[<p>TeX Live 是由国际 TeX 用户组（TUG）维护的 TeX 发行版，一般被认为是 TeX 发行版的「正统」，具有稳定、更新快、维护足的特点。</p>
<p>不过，使用 TeX Live 也有麻烦的地方——TeX Live 每年都更新，而更新版本之后旧版本就无法再从 CTAN 上自动更新宏包。这样一来，TeX Live 用户就不得不每年都重新安装一次，相当麻烦。而且，在新版测试期间更新的宏包，旧版本的用户就无法通过 <code>tlmgr</code> 来更新了。对于中国的用户而言，TeX Live 2014 向 TeX Live 2015 的过渡期尤为难熬，因为 <a href="/2015/05/16/ctex-20-released/">CTeX 宏集的新版本</a> 发布了。</p>
<p>这篇文章中，我将介绍如何在旧版本的 TeX Live 中跨版本更新宏包。</p>
<a id="more"></a>

<h2 id=" 原理 ">原理</h2>
<p>虽然听上去麻烦，但实际上还是还是很简单的。</p>
<p>默认情况下，TeX Live 通过新建一个以年份数字为名的目录来区分当前的 TeX Live 版本。比如，对于安装了 TeX Live 2014 的用户，会有这样的目录结构：</p>
<pre><code>-<span class="ruby"> texlive
</span>|- 2014
|- texmf-local
</code></pre><p>按照 TUG 的意图，如果用户在此基础上安装 TeX Live 2015，那么目录结构会变成：</p>
<pre><code>- texlive
<span class="string">|- 2014</span>
<span class="string">|- 2015</span>
<span class="string">|- texmf-local</span>
</code></pre><blockquote>
<p>这样做的好处是，用户可以自由地在不同版本之间切换，同时多个版本共用一个 <code>texmf-local</code> 目录（用户配置目录）。只是，对于大多数人的大多数情况来说，这是没有必要的。</p>
</blockquote>
<p>因此，为了将 TeX Live 2014 伪装成正在参与测试的 TeX Live 2015，我们首先要将目录名字修改成 <code>2015</code>。修改过目录之后，我们还需要正确处理 TeX 系统的二进制文件和系统 <code>PATH</code> 变量。在这之后，我们只需要将 <code>tlmgr</code> 的远程仓库设置为 <code>tlpretest</code> 仓库就好了。</p>
<h2 id=" 实际操作看看 ">实际操作看看</h2>
<p>这里我们以 TeX Live 2014 升级到 TeX Live 2015 pretest 为例，未来版本的升级步骤与此类似。</p>
<p>对于 MacTeX 2014 用户，可以在终端下进行如此操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="built_in">cd</span> /usr/local/texlive/
<span class="built_in">sudo</span> mv ./<span class="number">2014</span> ./<span class="number">2015</span>
<span class="built_in">cd</span> ./<span class="number">2015</span>/bin/x86_64-darwin
<span class="built_in">sudo</span> ./tlmgr option sys_bin /usr/texbin/
<span class="built_in">sudo</span> ./tlmgr path add
<span class="built_in">sudo</span> tlmgr option repository http://ctan.ijs.si/mirror/tlpretest/
<span class="built_in">sudo</span> tlmgr update --self --all
</pre></td></tr></table></figure>



<p>在这里：</p>
<ol>
<li>将工作目录切换到 <code>texlive</code> 目录</li>
<li>修改年份目录的名字，从 <code>2014</code> 修改为 <code>2015</code></li>
<li>由于修改目录名字破坏了 TeX 系统的二进制文件和系统 <code>PATH</code> 之间的关联，在进行下一步操作之后，我们需要切换到二进制文件目录</li>
<li>运行当前目录下的 <code>tlmgr</code> 工具，配置系统二进制文件的目录为 <code>/usr/texbin/</code></li>
<li>同样是运行当前目录下的 <code>tlmgr</code> 工具，将 TeX 系统的二进制文件和系统 <code>PATH</code> 重新关联起来</li>
<li>将 <code>tlmgr</code> 的远程仓库设置为 <code>tlpretest</code> 仓库，因为已经配置好上述关联，所以不需要用 <code>./</code> 来指明当前目录</li>
<li>使用 <code>tlmgr</code> 更新宏包和其他相关组件</li>
</ol>
<p>Linux 系统的操作和 Mac OS X 下的操作基本相同，不再赘述。</p>
<p>Windows 用户的操作基本可以在图形界面下操作：</p>
<ul>
<li>首先进入 TeX Live 的安装目录</li>
<li>然后修改文件夹的名字</li>
<li>在系统设置中，修改 <code>PATH</code> 变量的值</li>
<li>然后打开命令提示符窗口（cmd）</li>
<li>执行命令 <code>tlmgr option repository http://ctan.ijs.si/mirror/tlpretest/</code></li>
<li>执行命令 <code>tlmgr update --self --all</code></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>TeX Live 是由国际 TeX 用户组（TUG）维护的 TeX 发行版，一般被认为是 TeX 发行版的「正统」，具有稳定、更新快、维护足的特点。</p>
<p>不过，使用 TeX Live 也有麻烦的地方——TeX Live 每年都更新，而更新版本之后旧版本就无法再从 CTAN 上自动更新宏包。这样一来，TeX Live 用户就不得不每年都重新安装一次，相当麻烦。而且，在新版测试期间更新的宏包，旧版本的用户就无法通过 <code>tlmgr</code> 来更新了。对于中国的用户而言，TeX Live 2014 向 TeX Live 2015 的过渡期尤为难熬，因为 <a href="/2015/05/16/ctex-20-released/">CTeX 宏集的新版本</a> 发布了。</p>
<p>这篇文章中，我将介绍如何在旧版本的 TeX Live 中跨版本更新宏包。</p>
]]></summary>
    
      <category term="Fake" scheme="http://liam0205.me/tags/Fake/"/>
    
      <category term="tlpretest" scheme="http://liam0205.me/tags/tlpretest/"/>
    
      <category term="TeX Live" scheme="http://liam0205.me/tags/TeX%20Live/"/>
    
      <category term="Update" scheme="http://liam0205.me/tags/Update/"/>
    
      <category term="Packages" scheme="http://liam0205.me/tags/Packages/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[驱动选项错误导致「returned exit code (1)」的错误]]></title>
    <link href="http://liam0205.me/2015/06/01/returned-exit-code-not-0/"/>
    <id>http://liam0205.me/2015/06/01/returned-exit-code-not-0/</id>
    <published>2015-06-01T06:37:19.000Z</published>
    <updated>2015-06-01T06:57:35.000Z</updated>
    <content type="html"><![CDATA[<p>TeX 是一个相当庞大的系统，其中的程序、格式、宏包和工具繁多。新手比较容易接受直观的现象，对于 TeX 系统中繁琐抽象的概念则了解甚少。</p>
<p>比如说，新手听闻「LaTeX」之名，于是在编译的时候看见 pdfLaTeX 或 XeLaTeX 的时候就会犹豫：「这是不是我听说的那个 LaTeX 呢」。于是，新手可能会倾向于使用 LaTeX 去编译。编译完成之后，又面临着将 DVI 文件转化为 PDF 文件的问题，这时候新手又会面临两个选择：</p>
<ul>
<li>使用 <code>dvips</code> 先转换为 PS 文件，再使用 <code>ps2pdf</code> 转换为 PDF 文件</li>
<li>使用 <code>DVIPDFMx</code> 直接转换为 PDF 文件</li>
</ul>
<p>两种方式在新手眼中的差异直观而明显：「前一种方式多了 PS 文件这个中间步骤」。诚然，这是对的，但是却忽略了一些细节但关键的东西。这样不经意的忽略往往为后来的错误埋下了根源，比如新手经常会遇到下列一些错误：</p>
<ul>
<li>使用 WinEdt 时，弹出对话框提示「returned exit code (1)」</li>
<li>编译完成后不报错，但是插入的图片显示异常</li>
<li>编译完成后不报错，但是纸张尺寸或超链接异常</li>
</ul>
<p>这些错误往往是驱动选项错误导致的，准确地说，是驱动选项和实际使用的驱动不一致导致的。而所谓驱动，就是 <code>dvips</code> 和 <code>DVIPDFMx</code> 这些转换工具。</p>
<a id="more"></a>

<p>不同的生成 PDF 文件的路径，会用到不同的工具（我们称之为「驱动」）。这里给一个简单的列表：</p>
<ul>
<li>DVI - PS - PDF：LaTeX -&gt; dvips -&gt; ps2pdf，要用到 dvips 这个驱动</li>
<li>DVI - PDF: LaTeX -&gt; DVIPDFMx，要用到 DVIPDFMx 这个驱动</li>
<li>PDF (Directly): pdfLaTeX，驱动就是它自己（pdfTeX）</li>
<li>xDV - PDF: XeLaTeX -&gt; xDVIPDFMx，驱动是 xDVIPDFMx（默认自动调用）</li>
</ul>
<p>常见的编译方式，至少涉及到 dvips、DVIPDFMx、pdfTeX、xDVIPDFMx 四种驱动。这四种驱动对插图、PDF 书签、页面纸张大小等内容进行处理的时候，语法有细微的差别。为了让驱动正常工作，在 (pdf/Xe)LaTeX 编译的时候，就必须让相应的宏包按照驱动的要求工作。</p>
<p>现在的问题是，宏包怎么知道应当怎么工作？</p>
<p>如果你有注意到，就会发现，对于 pdfLaTeX 和 XeLaTeX 来说，能使用的驱动就只有一种情况；但是对于 LaTeX 来说，可以选择 dvips 和 DVIPDFMx 两种驱动。因此，如果用户选择 pdfLaTeX 或者 XeLaTeX 编译，那么宏包是可以自己检测到的，此时不需要进行特别的设置。但是，如果用户选择 LaTeX 编译，那么宏包就不知道应该怎么工作了。为了简化代码（也由于历史原因），这些宏包在用户使用 LaTeX 编译的时候，「默认使用」dvips 这个驱动；而如果希望使用 DVIPDFMx 的话，就需要在加载宏包的时候以宏包选项的方式给出说明。</p>
<p>那么什么时候会出错呢？</p>
<p>其实很简单：当实际使用的驱动和宏包的工作模式（取决于驱动选项）不一致的时候，就会出错。</p>
<p>比如，如果使用 <code>\usepackage[pdftex]{graphicx}</code> 载入 <code>graphicx</code> 宏包，那么就只能使用 pdfLaTeX 编译。此时使用 LaTeX 或者 XeLaTeX 都会报错。<br>又比如，如果使用 <code>\usepackage[dvipdfmx]{hyperref}</code> 载入 <code>hyperref</code> 宏包，那么就只能使用 LaTeX - DVIPDFMx 的方式编译。此时使用 pdfLaTeX、XeLaTeX 或者 LaTeX - dvips 的话就会报错。</p>
<p>更有甚者，如果是这样子：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="command">\usepackage</span><span class="special">[</span>pdftex<span class="special">]</span><span class="special">{</span>graphicx<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">[</span>dvipdfmx<span class="special">]</span><span class="special">{</span>hyperref<span class="special">}</span>
</pre></td></tr></table></figure>



<p>两个宏包使用的驱动选项不一致，那么不管怎么编译，都会报错。<br>喜欢「抄代码」的新手，经常遇到这样的问题：东抄抄西抄抄，结果两个作者没商量好，写出来的代码一个需要 pdfLaTeX 编译，另一个需要 LaTeX - DVIPDFMx 编译，于是就坑死了新手。<br>所以：代码自己写，不要抄代码。</p>
<p>总结一下，要想得到正确的结果，就必须根据使用的驱动来填写正确的宏包驱动选项。常见的情况记录如下：</p>
<ul>
<li>LaTeX - dvips：默认情况，可以不给驱动选项，也可以给驱动选项 dvips</li>
<li>LaTeX - DVIPDFMx：无法自动检测，必须手工给出驱动选项 dvipdfm 或者 dvipdfmx （详情查阅相应宏包文档）</li>
<li>pdfLaTeX：可以自动检测，因此可以不给驱动选项，也可以给驱动选项 pdftex</li>
<li>XeLaTeX：可以自动检测，因此可以不给驱动选项，也可以给驱动选项 xetex</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>TeX 是一个相当庞大的系统，其中的程序、格式、宏包和工具繁多。新手比较容易接受直观的现象，对于 TeX 系统中繁琐抽象的概念则了解甚少。</p>
<p>比如说，新手听闻「LaTeX」之名，于是在编译的时候看见 pdfLaTeX 或 XeLaTeX 的时候就会犹豫：「这是不是我听说的那个 LaTeX 呢」。于是，新手可能会倾向于使用 LaTeX 去编译。编译完成之后，又面临着将 DVI 文件转化为 PDF 文件的问题，这时候新手又会面临两个选择：</p>
<ul>
<li>使用 <code>dvips</code> 先转换为 PS 文件，再使用 <code>ps2pdf</code> 转换为 PDF 文件</li>
<li>使用 <code>DVIPDFMx</code> 直接转换为 PDF 文件</li>
</ul>
<p>两种方式在新手眼中的差异直观而明显：「前一种方式多了 PS 文件这个中间步骤」。诚然，这是对的，但是却忽略了一些细节但关键的东西。这样不经意的忽略往往为后来的错误埋下了根源，比如新手经常会遇到下列一些错误：</p>
<ul>
<li>使用 WinEdt 时，弹出对话框提示「returned exit code (1)」</li>
<li>编译完成后不报错，但是插入的图片显示异常</li>
<li>编译完成后不报错，但是纸张尺寸或超链接异常</li>
</ul>
<p>这些错误往往是驱动选项错误导致的，准确地说，是驱动选项和实际使用的驱动不一致导致的。而所谓驱动，就是 <code>dvips</code> 和 <code>DVIPDFMx</code> 这些转换工具。</p>
]]></summary>
    
      <category term="Driver" scheme="http://liam0205.me/tags/Driver/"/>
    
      <category term="Exit Code" scheme="http://liam0205.me/tags/Exit%20Code/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CTeX 2.0 发布 · 新功能简介]]></title>
    <link href="http://liam0205.me/2015/05/16/ctex-20-released/"/>
    <id>http://liam0205.me/2015/05/16/ctex-20-released/</id>
    <published>2015-05-16T15:04:52.000Z</published>
    <updated>2015-05-28T08:29:29.000Z</updated>
    <content type="html"><![CDATA[<p>CTeX 2.0 的代码主要是 李清 用 LaTeX 3 的语法书写的。之后 刘海洋 对代码做了一些调整，并构建了第一个版本的宏集手册。再之后，在测试版本发布之后，我重构了宏集手册，成为你们现在看到的这个样子。</p>
<p>现在，新版宏集已经上传，CTAN 地址是：<a href="http://www.ctan.org/pkg/ctex" target="_blank">http://www.ctan.org/pkg/ctex</a></p>
<a id="more"></a>

<p>首先说一下关于 CTeX 这个名字。<br>CTeX 的 C 是 China 或者 Chinese 的意思，在纯文本环境下，应该写作 CTeX。<br>CTeX 宏集是由 CTeX 社区 发起并维护的 LaTeX 宏包和文档类集合。社区另有发布名为 CTeX 套装 的 TeX 发行版。<br>ctex 是本宏集中 <code>ctex.sty</code> 的名字。这一小写的名字过去被用来代指整个 CTeX 宏集，不过现在则专指 <code>ctex.sty</code> 这一宏包。不过，在一些特殊的情况下，由于历史原因，为了与 CTeX 套装做区分，也会用 ctex 来代指整个 CTeX 宏集。</p>
<p>本次更新的是 CTeX 宏集，版本号从 1.02d 升级到 2.0 （当前修复了一些问题，版本号是 2.0.2）。CTeX 套装的最新版本是 2.9.2.164，已有若干年未更新，将来可能也不会再更新，也不推荐使用。</p>
<p>CTeX 2.0 里比较重大的改变有四个：</p>
<ul>
<li>对底层引擎的支持，放弃了 CCT，新增了 LuaLaTeX（基于 <code>LuaTeX-ja</code>）；</li>
<li>增强了字库选择，新增了华文、Fandol、方正等字库，并提供了基于操作系统自动选择字库的功能；</li>
<li>增强了 <code>ctex.sty</code> 的功能，用键值列表的方式提供选项支持，并提供全新的 \ctexset 接口；</li>
<li>关于字号的部分，在 <code>ctexsize.sty</code> 中单独列出，可独立于 CTeX 宏包或文档类使用。</li>
</ul>
<p>除此之外，特别有意义的一点是，新版宏集可以做到「只提供中文支持，不改变版式风格」。只需要这样：</p>
<pre><code><span class="attribute">\usepackage[scheme </span>=<span class="string"> plain]{ctex}</span>
</code></pre><p>特别适用于在英文文档中需要添加少许汉字的情况。</p>
<p>除此之外，用户可能会比较关心新版宏集对旧版宏包的兼容性问题。CTeX 2.0 对使用时间较长的稳定版本 1.02c 和 1.02d 做了尽可能的兼容。基于这两个旧版本的宏包书写的文档，在新版本下可以不作任何修改地编译，并且效果几乎一致，但有一些过时选项需要注意。这些选项在新版宏集中基于兼容性考虑被保留，但在将来可能被移除。完整的兼容性可参看宏集手册 12.2 节，这里列出部分比较重要的：</p>
<ul>
<li><code>cs4size</code> 和 <code>c5size</code>：旧版宏包用于选择文档全局字号的选项，已过时，相当于新版宏集 <code>zihao = -4</code> 和 <code>zihao = 5</code> 的功能。</li>
<li><code>cap</code> 和 <code>nocap</code>：旧版宏包用于选择排版风格的选项，已过时，相当于新版宏集 <code>scheme = chinese</code> 和 <code>scheme = plain</code> 的功能。</li>
<li><code>fancyhdr</code>, <code>hyperref</code> 和 <code>fntef</code>：旧版宏包的兼容性选项，均已过时。新版宏集默认打开兼容性，不过需要用户手工载入相关宏包（<code>fancyhdr</code> 和 <code>hyperref</code>）。出于兼容性考虑，选项保留，功能是载入相关宏包。</li>
<li><code>ctexcap.sty</code>：过时宏包，相当于 <code>\usepackage[heading = true]{ctex}</code>，不推荐使用。</li>
</ul>
<p>具体的内容，烦请参看新版宏集手册。关于 <code>\ctexset</code>，有不少「很犀利」的用法哦~</p>
]]></content>
    <summary type="html"><![CDATA[<p>CTeX 2.0 的代码主要是 李清 用 LaTeX 3 的语法书写的。之后 刘海洋 对代码做了一些调整，并构建了第一个版本的宏集手册。再之后，在测试版本发布之后，我重构了宏集手册，成为你们现在看到的这个样子。</p>
<p>现在，新版宏集已经上传，CTAN 地址是：<a href="http://www.ctan.org/pkg/ctex" target="_blank">http://www.ctan.org/pkg/ctex</a></p>
]]></summary>
    
      <category term="CTeX" scheme="http://liam0205.me/tags/CTeX/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hyperref 宏包 psdextra 选项的 bug 及其 quick fix]]></title>
    <link href="http://liam0205.me/2015/05/11/bug-of-the-hyperref-package-with-mu-in-section-heading/"/>
    <id>http://liam0205.me/2015/05/11/bug-of-the-hyperref-package-with-mu-in-section-heading/</id>
    <published>2015-05-11T15:04:10.000Z</published>
    <updated>2015-05-11T15:17:41.000Z</updated>
    <content type="html"><![CDATA[<p>今天有人问到下列代码报错：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>article<span class="special">}</span>
<span class="comment">%\listfiles</span>
<span class="command">\usepackage</span><span class="special">[</span>unicode,psdextra<span class="special">]</span><span class="special">{</span>hyperref<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>unicode-math<span class="special">}</span>
<span class="command">\setmathfont</span><span class="special">{</span>Asana Math<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\section</span><span class="special">{</span><span class="formula">$<span class="command">\mu</span>$</span><span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>提示：</p>
<pre><code>Improper alphabetic <span class="built_in">constant</span>
</code></pre><p>看了一下，是 <code>hyperref</code> 宏包的 bug。</p>
<a id="more"></a>

<p>实际上，在处理 PDF 书签的时候，很多数学命令要被定义成相应的文本模式，比如 \geq 要被定义为 \textgeq。这个工作在 NFSS 里完成。</p>
<p>但是，数学符号那么多，总有 NFSS 定义不全的时候。于是 hyperref 提供了 psdextra 选项。该选项会载入 psdextra.def 这个文件，提供更多的定义。</p>
<p>不过 \mu 在 NFSS 里和 psdextra.def 里都处理错了。psdextra 里是处理了 \mugreek，而实际上应该是 \mu。于是就出问题了。</p>
<p>解决方法也很简单，自己处理一下就好了。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>article<span class="special">}</span>
<span class="comment">%\listfiles</span>
<span class="command">\usepackage</span><span class="special">[</span>unicode, psdextra<span class="special">]</span><span class="special">{</span>hyperref<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>unicode-math<span class="special">}</span>
<span class="command">\setmathfont</span><span class="special">{</span>Asana-Math.otf<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>etoolbox<span class="special">}</span>
<span class="command">\appto</span><span class="special">{</span><span class="command">\psdmapshortnames</span><span class="special">}</span><span class="special">{</span><span class="command">\let</span><span class="command">\mu</span><span class="command">\textmugreek</span><span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\section</span><span class="special">{</span><span class="formula">$<span class="command">\mu</span>$</span><span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>这里 <code>\appto</code> 命令接受两个参数，<code>\appto{&lt; 需要修补的命令 &gt;}{&lt; 填在命令最后的内容 &gt;}</code>。这里我们将 <code>\let\mu\textmugreek</code> 添加在命令 <code>\psdmapshortnames</code> 的最后，这样在处理 PDF 书签的时候，<code>\mu</code> 就能被正确处理了。</p>
<p>该 bug 已提交给 <code>hyperref</code> 宏包的作者。</p>
]]></content>
    <summary type="html"><![CDATA[<p>今天有人问到下列代码报错：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>article<span class="special">}</span>
<span class="comment">%\listfiles</span>
<span class="command">\usepackage</span><span class="special">[</span>unicode,psdextra<span class="special">]</span><span class="special">{</span>hyperref<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>unicode-math<span class="special">}</span>
<span class="command">\setmathfont</span><span class="special">{</span>Asana Math<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\section</span><span class="special">{</span><span class="formula">$<span class="command">\mu</span>$</span><span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>提示：</p>
<pre><code>Improper alphabetic <span class="built_in">constant</span>
</code></pre><p>看了一下，是 <code>hyperref</code> 宏包的 bug。</p>
]]></summary>
    
      <category term="Bug" scheme="http://liam0205.me/tags/Bug/"/>
    
      <category term="Hyperref" scheme="http://liam0205.me/tags/Hyperref/"/>
    
      <category term="Psdextra" scheme="http://liam0205.me/tags/Psdextra/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用 Python 生成随机的邀请码]]></title>
    <link href="http://liam0205.me/2015/05/07/generator-of-invitation-code-in-python/"/>
    <id>http://liam0205.me/2015/05/07/generator-of-invitation-code-in-python/</id>
    <published>2015-05-07T13:34:23.000Z</published>
    <updated>2015-05-07T13:34:14.000Z</updated>
    <content type="html"><![CDATA[<p>在很多场合，我们都需要生成一系列固定长度的字符串，分发给用户，作为邀请码或者兑换码。</p>
<p>关于邀请码，最容易想到的特征有二：一是足够长，二是不具有规律性。这两个特征主要是为了防止用户伪造邀请码，简单来说，就是让用户「猜对」正确邀请码的可能性足够小。不过，作为邀请码来说，仅有这两个特征还不够。</p>
<p>邀请码并不是发放给用户就结束了，还涉及到验证的过程。用户在收到邀请码之后，将邀请码提交给系统。系统在收到提交之后，要在数据库里查询是否有匹配的记录。所以生成邀请码时除了要防止用户伪造，还要方便后期的校验。这就要求我们能够从邀请码中，经过简单的变换，提取出「主键」。</p>
<p>这篇文章我们讨论一下如何用 Python 生成随机的邀请码。</p>
<a id="more"></a>

<h2 id=" 产生随机数 ">产生随机数</h2>
<p>Python 有自带的随机库，其名为 <code>random</code>。<code>random</code> 库中的 <code>randint(inf, sup)</code> 函数可以在指定的范围内产生一个随机整数；<code>choice(sequence)</code> 可以在一个有序的类型中（比如 <code>list</code>、<code>tuple</code> 或 <code>string</code>）随机选取一个元素。</p>
<p>这里我们需要产生一个 15 位的随机串，可以包含数字和大小写字母。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment"># import random, string</span>

poolOfChars  = string.ascii_letters + string.digits
random_codes = <span class="keyword">lambda</span> x, y: <span class="string">''</span>.join([random.choice(x) <span class="keyword">for</span> i <span class="keyword">in</span> range(y)])

<span class="keyword">print</span> random_codes(poolOfChars, <span class="number">15</span>)
</pre></td></tr></table></figure>



<h2 id=" 填充空位 ">填充空位</h2>
<p>为了方便统计，主键通常是一个递增的整数序列。如果主键的值从 1 增加到 1000，那么主键的「（十进制）位数」就会从 1 增加到 4。对于邀请码来说，我们需要固定其总长度。反应到主键上，我们就需要固定主键的长度。最简单的办法，就是用 0 填充（pad）空位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">LengthError</span><span class="params">(ValueError)</span>:</span>
   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span>
      self.args = arg

<span class="function"><span class="keyword">def</span> <span class="title">pad_zero_to_left</span><span class="params">(inputNumString, totalLength)</span>:</span>
    <span class="string">'''
    takes inputNumString as input,
    pads zero to its left, and make it has the length totalLength
    1. calculates the length of inputNumString
    2. compares the length and totalLength
        2.1 if length &gt; totalLength, raise an error
        2.2 if length == totalLength, return directly
        2.3 if length &lt; totalLength, pads zeros to its left
    '''</span>
    lengthOfInput = len(inputNumString)
    <span class="keyword">if</span> lengthOfInput &gt; totalLength:
        <span class="keyword">raise</span> LengthError(<span class="string">"The length of input is greater than the total\ length."</span>)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> <span class="string">'0'</span> * (totalLength - lengthOfInput) + inputNumString
</pre></td></tr></table></figure>



<h2 id=" 拼接 ">拼接</h2>
<p>至此，我们已经得到了主键和随机序列产生的方法，剩下的问题就是要拼接起来。拼接两个字符串很容易，但是我们在拼接完成之后，还要保证能够很容易地找到主键的部分。</p>
<p>为了达成这个目的，我们只需要在主键和随机串之间加上一个固定的字母，比如 <code>L</code>，作为标识符。</p>
<pre><code>bGH49U63p5zy3ULL0123
</code></pre><p>这样我们就知道，整个邀请码子串最后一个 <code>L</code> 之后，就是主键部分。我们有代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">invitation_code_generator</span><span class="params">(quantity, lengthOfRandom, LengthOfKey)</span>:</span>
    <span class="string">'''
    generate `quantity` invitation codes
    '''</span>
    placeHoldChar = <span class="string">"L"</span>
    <span class="keyword">for</span> index <span class="keyword">in</span> range(quantity):
        tempString = <span class="string">""</span>
        <span class="keyword">try</span>:
            <span class="keyword">yield</span> random_codes(poolOfChars, lengthOfRandom) + placeHoldChar + \
                pad_zero_to_left(str(index), LengthOfKey)
        <span class="keyword">except</span> LengthError:
            <span class="keyword">print</span> <span class="string">"Index exceeds the length of master key."</span>

<span class="keyword">for</span> invitationCode <span class="keyword">in</span> invitation_code_generator(<span class="number">200</span>, <span class="number">15</span>, <span class="number">4</span>):
    <span class="keyword">print</span> invitationCode
</pre></td></tr></table></figure>



<p>这样，我们就生成了 200 个邀请码。其中随机串长度为 15，主键长度为 4，分隔符为字母 <code>L</code>。</p>
]]></content>
    <summary type="html"><![CDATA[<p>在很多场合，我们都需要生成一系列固定长度的字符串，分发给用户，作为邀请码或者兑换码。</p>
<p>关于邀请码，最容易想到的特征有二：一是足够长，二是不具有规律性。这两个特征主要是为了防止用户伪造邀请码，简单来说，就是让用户「猜对」正确邀请码的可能性足够小。不过，作为邀请码来说，仅有这两个特征还不够。</p>
<p>邀请码并不是发放给用户就结束了，还涉及到验证的过程。用户在收到邀请码之后，将邀请码提交给系统。系统在收到提交之后，要在数据库里查询是否有匹配的记录。所以生成邀请码时除了要防止用户伪造，还要方便后期的校验。这就要求我们能够从邀请码中，经过简单的变换，提取出「主键」。</p>
<p>这篇文章我们讨论一下如何用 Python 生成随机的邀请码。</p>
]]></summary>
    
      <category term="Python" scheme="http://liam0205.me/tags/Python/"/>
    
      <category term="Invitation Code" scheme="http://liam0205.me/tags/Invitation%20Code/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让所有的公式都使用正文直立字体]]></title>
    <link href="http://liam0205.me/2015/05/07/make-every-equations-in-your-document-upright/"/>
    <id>http://liam0205.me/2015/05/07/make-every-equations-in-your-document-upright/</id>
    <published>2015-05-07T09:33:54.000Z</published>
    <updated>2015-05-07T09:53:34.000Z</updated>
    <content type="html"><![CDATA[<p>首先说明，<strong>这是邪道</strong>，除非你知道自己在干什么，请不要使用这篇文章提到的方法。这篇文章纯粹是一个技巧的记录，在某些时候可能会有用。</p>
<p>有时候我们会需要将公式字体修改为正文的 <code>\rmfamily\upright\normalsize</code> 的样式。虽然看起来很复杂，其实却很简单。我们只需要在导言区末尾添加以下两行代码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="command">\everymath</span><span class="command">\expandafter</span><span class="special">{</span><span class="command">\the</span><span class="command">\everymath</span><span class="command">\mathgroup</span>0<span class="special">}</span>
<span class="command">\everydisplay</span><span class="command">\expandafter</span><span class="special">{</span><span class="command">\the</span><span class="command">\everydisplay</span><span class="command">\mathgroup</span>0<span class="special">}</span>
</pre></td></tr></table></figure>



<a id="more"></a>

<h3 id=" 解释 ">解释</h3>
<p>这里实际起作用的是 <code>\mathgroup0</code>。它将数学字体设置为第 <code>0</code> 组字体，也就是正文字体。</p>
<p>而 <code>\expandafter{\the\everymath</code> 能在外层的 <code>\everymath</code> 起作用之前，先将内层的 <code>\everymath</code> 展开。这样可以将 <code>\everymath</code> 的结果保留。若不然，比如有代码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="command">\everymath</span><span class="special">{</span><span class="command">\displaystyle</span><span class="special">}</span>
<span class="command">\everymath</span><span class="special">{</span><span class="command">\mathgroup</span>0<span class="special">}</span>
</pre></td></tr></table></figure>



<p>作者的本意是将每个行内数学公式都是用 <code>\displaystyle</code>，同时设置字体为正文字体。但实际上，由于第二行的存在，第一行的效果被覆盖掉了。为了保证我们添加的代码不影响已有的设置，所以要用 <code>\expandafter{\the\everymath</code> 的方式对已有的设置进行保护。例如，下面的代码则可以达到目的：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="command">\everymath</span><span class="special">{</span><span class="command">\displaystyle</span><span class="special">}</span>
<span class="command">\everymath</span><span class="command">\expandafter</span><span class="special">{</span><span class="command">\the</span><span class="command">\everymath</span><span class="command">\mathgroup</span>0<span class="special">}</span>
</pre></td></tr></table></figure>



]]></content>
    <summary type="html"><![CDATA[<p>首先说明，<strong>这是邪道</strong>，除非你知道自己在干什么，请不要使用这篇文章提到的方法。这篇文章纯粹是一个技巧的记录，在某些时候可能会有用。</p>
<p>有时候我们会需要将公式字体修改为正文的 <code>\rmfamily\upright\normalsize</code> 的样式。虽然看起来很复杂，其实却很简单。我们只需要在导言区末尾添加以下两行代码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="command">\everymath</span><span class="command">\expandafter</span><span class="special">{</span><span class="command">\the</span><span class="command">\everymath</span><span class="command">\mathgroup</span>0<span class="special">}</span>
<span class="command">\everydisplay</span><span class="command">\expandafter</span><span class="special">{</span><span class="command">\the</span><span class="command">\everydisplay</span><span class="command">\mathgroup</span>0<span class="special">}</span>
</pre></td></tr></table></figure>



]]></summary>
    
      <category term="Equation" scheme="http://liam0205.me/tags/Equation/"/>
    
      <category term="Font" scheme="http://liam0205.me/tags/Font/"/>
    
      <category term="Upright" scheme="http://liam0205.me/tags/Upright/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PIL 简明教程 - 在现有的图片上涂涂改改]]></title>
    <link href="http://liam0205.me/2015/05/05/pil-tutorial-imagedraw-and-imagefont/"/>
    <id>http://liam0205.me/2015/05/05/pil-tutorial-imagedraw-and-imagefont/</id>
    <published>2015-05-04T16:15:06.000Z</published>
    <updated>2015-05-24T05:00:26.000Z</updated>
    <content type="html"><![CDATA[<p><a href="/2015/04/22/pil-tutorial-basic-usage/">上一篇文章</a> 介绍了 PIL 的基本情况，以及 <code>Image</code> 模块的基本用法。这篇文章，我们讨论一下 <code>ImageDraw</code> 和 <code>ImageFont</code> 两个模块的基本用法，说说如何用 PIL 在现有的图片上涂涂改改。</p>
<p>系列文章列表：</p>
<ol>
<li><a href="/2015/04/22/pil-tutorial-basic-usage/">基本用法</a></li>
<li><a href="/2015/05/05/pil-tutorial-imagedraw-and-imagefont/"><code>ImageDraw</code> 和 <code>ImageFont</code> 模块</a></li>
</ol>
<a id="more"></a>

<h2 id="ImageDraw_ 模块 "><code>ImageDraw</code> 模块</h2>
<p><code>ImageDraw</code> 模块提供了 <code>Draw</code> 类，它能在 <code>Image</code> 实例上进行简单的 2D 绘图。当然复杂的绘图动作是由简单的动作合成而得的，理论上这些动作 <code>ImageDraw</code> 模块也能做，只是相对复杂。如果你想在 <code>Image</code> 实例上做复杂的绘图动作，最好是自行对 <code>ImageDraw</code> 模块提供的各种方法做一些封装。</p>
<h3 id=" 创建一个 _Draw_ 类的实例 ">创建一个 <code>Draw</code> 类的实例</h3>
<p>要在 <code>Image</code> 实例上绘制新的图样，首先要做的就是创建一个 <code>Draw</code> 类的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw
sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
drawAvatar     = ImageDraw.Draw(avatar)
</pre></td></tr></table></figure>



<p>代码前三行我们已经见过，唯一的差别在于 <code>import</code> 之后除了我们已经见过的 <code>Image</code> 模块，还有今次我们要使用的 <code>ImageDraw</code> 模块。</p>
<h3 id=" 从画两条平行线开始 ">从画两条平行线开始</h3>
<p><code>Draw</code> 类提供了 <code>line(xy, options)</code> 方法绘制直线。</p>
<p>其中 <code>xy</code> 表示坐标列表，其形式可以是</p>
<ul>
<li><code>[(x1, y1), (x2, y2), ...]</code> - 包含若干个元组的列表</li>
<li><code>[x1, y1, x2, y2, ...]</code> - 按照顺序包含坐标信息的列表</li>
<li><code>[x1, y1, (x2, y2), ...]</code> - 以上两种情况的混合</li>
<li><code>((x1, y1), (x2, y2), ...)</code> - 包含若干个元组的元组</li>
<li><code>(x1, y1, x2, y2, ...)</code> - 按照顺序包含坐标信息的元组</li>
<li><code>(x1, y1, (x2, y2), ...)</code> - 以上两种情况的混合</li>
</ul>
<p><code>options</code> 中可用的选项有</p>
<ul>
<li><code>fill = (R, G, B)</code> - 用于指定线条的颜色，其中 <code>R</code>、<code>G</code>、<code>B</code> 都是 0 — 255 的整数</li>
<li><code>width = integer</code> - 用于指定线条的宽度，单位是像素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw
sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
drawAvatar     = ImageDraw.Draw(avatar)

xSize, ySize = avatar.size

drawAvatar.line([<span class="number">0</span>, <span class="number">0.33</span> * ySize, xSize, <span class="number">0.33</span> * ySize],\
    fill = (<span class="number">255</span>, <span class="number">100</span>, <span class="number">0</span>), width = <span class="number">3</span>)
drawAvatar.line([<span class="number">0</span>, <span class="number">0.67</span> * ySize, xSize, <span class="number">0.67</span> * ySize],\
    fill = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), width = <span class="number">3</span>)
<span class="keyword">del</span> drawAvatar

avatar.show()
</pre></td></tr></table></figure>



<p>这里我们在图片的两个三等分位置分别画了一条宽度为 3 像素的平行线。一条颜色为 (255, 100, 0)，另一条则是 (255, 0, 0)。</p>
<p>值得注意的是代码的第 14 行，我们直接用 <code>avatar.show()</code> 来展现绘图的结果。可见<strong><code>Draw</code> 类的实例将直接在 <code>Image</code> 实例上进行操作</strong>。</p>
<p><img src="/attachment/images/Python/pil-tutorial/draw-line.png" alt="line 方法效果示例 "></p>
<h3 id=" 画一段弧 ">画一段弧</h3>
<p><code>Draw</code> 类也提供了 <code>arc(xy, start, end, options)</code> 方法来绘制弧。</p>
<p>这里的 <code>xy</code> 是一个长度为 4 的列表，用来表示一个 bounding box（参考上一篇文章）。<code>start</code> 和 <code>end</code> 则是弧的起止角度，单位是 °。其中水平向右的方向为 0°，竖直向下的方向为 90°，水平向左的方向为 180°，竖直向上的方向为 270°。</p>
<p><code>options</code> 中可用的选项有</p>
<ul>
<li><code>fill = (R, G, B)</code> - 用于指定线条的颜色，其中 <code>R</code>、<code>G</code>、<code>B</code> 都是 0 — 255 的整数</li>
</ul>
<p><code>arc</code> 方法将在内切于 bounding box 的椭圆中，按照给定的起止角度切下一段弧，并绘制于 <code>Image</code> 示例之上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw
sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
drawAvatar     = ImageDraw.Draw(avatar)

xSize, ySize = avatar.size

drawAvatar.arc([<span class="number">0</span>, <span class="number">0</span>, xSize, ySize], <span class="number">0</span>, <span class="number">90</span>,\
    fill = (<span class="number">255</span>, <span class="number">100</span>, <span class="number">255</span>))
<span class="keyword">del</span> drawAvatar

avatar.show()
</pre></td></tr></table></figure>



<p><img src="/attachment/images/Python/pil-tutorial/draw-arc.png" alt="arc 方法效果示例 "></p>
<h3 id=" 在图片上写字 ">在图片上写字</h3>
<p><code>Draw</code> 类提供了 <code>text(position, string, options)</code> 方法，该方法可以在 <code>Image</code> 实例上写字。</p>
<p>需要说明的是，<code>position</code> 指定的是文本左上角的顶点，而不是文本中心。这里可用的 <code>options</code> 有</p>
<ul>
<li><code>font = ImageFont instance</code> - 指定字体，接受一个 <code>ImageFont</code> 的实例</li>
<li><code>fill = (R, G, B)</code> - 用于指定线条的颜色，其中 <code>R</code>、<code>G</code>、<code>B</code> 都是 0 — 255 的整数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw
sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
drawAvatar     = ImageDraw.Draw(avatar)

xSize, ySize = avatar.size

drawAvatar.text([<span class="number">0.9</span> * xSize, <span class="number">0.1</span> * ySize - drawAvatar.textsize(<span class="string">"3"</span>)[<span class="number">1</span>]],\
    <span class="string">"3"</span>, fill = (<span class="number">128</span>, <span class="number">0</span>, <span class="number">128</span>))
<span class="keyword">del</span> drawAvatar

avatar.show()
</pre></td></tr></table></figure>



<p><img src="/attachment/images/Python/pil-tutorial/draw-text.png" alt="text 方法效果示例 "></p>
<p>由于没有用 <code>font</code> 选项指定字体，这里使用了 <code>ImageDraw</code> 的默认字体。不难发现，相对图片，字体太小了。为了调整字体，我们需要借助 <code>ImageFont</code> 模块。</p>
<h2 id="ImageFont_ 模块 "><code>ImageFont</code> 模块</h2>
<p><code>ImageFont</code> 模块很简单，它定义了一个同名的类。<code>ImageFont</code> 类的实例可以传给 <code>ImageDraw</code> 中 <code>text</code> 方法的 <code>font</code> 的参数，起到字体选择的作用。</p>
<p><code>ImageFont</code> 模块中的 <code>load</code> 函数可以加载一个 Image 格式的字体，并返回 <code>ImageFont</code> 实例；其中的 <code>truetype(fontfile, fontsize)</code> 函数则可以加载 TrueType 或 OpenType 格式的字体，并返回 <code>ImageFont</code> 参数。不过 <code>truetype</code> 函数需要额外安装 <code>_imagingft</code> 模块。</p>
<p>配置好之后，我们可以对上一节末尾的代码稍作修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont

sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
drawAvatar     = ImageDraw.Draw(avatar)

xSize, ySize = avatar.size
fontSize     = min(xSize, ySize) // <span class="number">11</span>

myFont       = ImageFont.truetype(<span class="string">"/Library/Fonts/OsakaMono.ttf"</span>, fontSize)

drawAvatar.text([<span class="number">0.9</span> * xSize, <span class="number">0.1</span> * ySize - fontSize],\
    <span class="string">"3"</span>, fill = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), font = myFont)
<span class="keyword">del</span> drawAvatar

avatar.show()
</pre></td></tr></table></figure>



<p>这里我们引入了 <code>ImageFont</code> 模块，并且创建了 <code>myFont</code> 实例。创建实例的时候，传入的字体尺寸由图片大小决定。最后在图片上写字的位置也与字体大小有关。</p>
<p>这样以来，我们就在图片的右上角写了一个红色的数字，就好像微信未读消息提示的那种效果。</p>
<p><img src="/attachment/images/Python/pil-tutorial/draw-text-font.png" alt=" 引入 font 选项的 text 方法效果示例 "></p>
<h2 id=" 小结 ">小结</h2>
<p><code>ImageDraw</code> 模块还有许多其他的功能，比如绘制椭圆、多边形、矩形等。限于篇幅，这里就不一一介绍了。感兴趣的读者可以参看官方文档：</p>
<p><a href="http://effbot.org/imagingbook/imagedraw.htm#methods" target="_blank">http://effbot.org/imagingbook/imagedraw.htm#methods</a></p>
]]></content>
    <summary type="html"><![CDATA[<p><a href="/2015/04/22/pil-tutorial-basic-usage/">上一篇文章</a> 介绍了 PIL 的基本情况，以及 <code>Image</code> 模块的基本用法。这篇文章，我们讨论一下 <code>ImageDraw</code> 和 <code>ImageFont</code> 两个模块的基本用法，说说如何用 PIL 在现有的图片上涂涂改改。</p>
<p>系列文章列表：</p>
<ol>
<li><a href="/2015/04/22/pil-tutorial-basic-usage/">基本用法</a></li>
<li><a href="/2015/05/05/pil-tutorial-imagedraw-and-imagefont/"><code>ImageDraw</code> 和 <code>ImageFont</code> 模块</a></li>
</ol>
]]></summary>
    
      <category term="Python" scheme="http://liam0205.me/tags/Python/"/>
    
      <category term="PIL" scheme="http://liam0205.me/tags/PIL/"/>
    
      <category term="ImageDraw" scheme="http://liam0205.me/tags/ImageDraw/"/>
    
      <category term="ImageFont" scheme="http://liam0205.me/tags/ImageFont/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[英语语法之三：动词时态]]></title>
    <link href="http://liam0205.me/2015/05/03/tense-of-verb/"/>
    <id>http://liam0205.me/2015/05/03/tense-of-verb/</id>
    <published>2015-05-03T10:06:39.000Z</published>
    <updated>2015-05-04T04:07:34.000Z</updated>
    <content type="html"><![CDATA[<p>这个系列的 <a href="http://liam0205.me/2014/06/22/noun-phrase-and-articles/">上一篇文章</a> 已经快一年了。我真是懒啊……</p>
<p>中文的谓语动词不在时间、状态、语态上作区分。在中文中，这些功能由其它副词提供。在英文中，动词的形态需要根据时间、状态、语态发生改变。对于中国人来说，这样的变化确实有些不自然；选错时态也是中国人讲英文时经常犯的错误。</p>
<p>在这里，语态和说话人的态度相关，比较容易感受。同时，语态反应在动词形态上的变化也相对简单，只需要加上合适的 <code>be</code> 动词，配上动词的过去分词即可。时态和动作发生的时间相关，也相对直观。因此，如果我们能对状态做一些简化，从状态出发去讨论时态，则问题会简单得多。</p>
<a id="more"></a>

<h2 id=" 状态的简化 ">状态的简化</h2>
<p>在现代英语中，状态分为</p>
<ul>
<li>一般状态（如：一般现在式）</li>
<li>进行状态（如：一般进行式）</li>
<li>完成状态（如：现在完成式）</li>
</ul>
<p>其中，进行状态的语法特征是 <code>be + 动词的现在分词（V-ing）</code>。如果我们「暂时忘掉」进行状态这个概念，把上述结构看做是 <code>be</code> 动词加上补语（表语）的结构，那这个结构和传统语法中的「一般状态」就没什么区别了。只不过，进行状态的动词是个 <code>be</code> 动词而已。也就是说，我们完全可以把进行状态看做是一种特殊的一般状态，它的谓语动词是个空的 <code>be</code> 动词。</p>
<p>因此，我们可以将一般状态和进行状态合并在一起，称之为「简单式」。为了统一称呼，我们把完成状态叫做「完成式」。</p>
<p>注意，这里的简化并不受语态影响。相对主动语态，被动语态不过是 <code>be + 动词的过去分词（V-ed）</code>而已。我们依然可以把被动语态当做 <code>be</code> 动词加上补语（表语）的结构。这样，语态完全不影响上述简化过程。</p>
<h2 id=" 简单式 ">简单式</h2>
<p>简单式有几个重要的特征：</p>
<ul>
<li><strong>简单式的动作，其发生的具体时间是一个特定的时间段</strong></li>
<li><strong>动作发生的时间段可大可小，可以延伸至无穷远的过去或无穷远的将来，也可以缩小至一个具体的时间点</strong></li>
<li><strong>如果动作发生的时间段</strong><ul>
<li>包括「现在」这个时间点，那么用现在时态</li>
<li>不包括「现在」这个时间点，且位于现在之前，那么用过去时态</li>
<li>不包括「现在」这个时间点，且位于现在之后，那么用将来时态</li>
</ul>
</li>
</ul>
<p>第一个特征，给了我们明确的信息来确定我们是否应该使用简单式（而不是完成式）。第二和第三个特征，则为我们选择时态提供了依据。</p>
<h3 id=" 过去时态 ">过去时态</h3>
<blockquote>
<p>The U.S.A <em>established</em> diplomatic relations with the P.R.C <em>in 1979</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>1979 年</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 <code>be</code> 动词</li>
</ul>
<p>因此，动词 <code>establish</code> 应该用过去式 <code>established</code>。这是传统语法的「一般过去式」。</p>
<blockquote>
<p>The movable print <em>was</em> introduced to England <em>in 1485</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>1979 年</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态</li>
<li>这里涉及到被动的语态，但不涉及到「持续」或者「正在发生」的含义，所以需要用 <code>be + V-ed</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的过去形态 <code>was</code>，以及 <code>introduced</code> 这个过去分词。这是传统语法的「一般过去式被动语态」。</p>
<blockquote>
<p>I <em>was</em> visiting clients <em>the whole day yesterday</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>昨天一整天</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态</li>
<li>这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 <code>be + V-ing</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的过去形态 <code>was</code>，以及 <code>visiting</code> 这个现在分词。这是传统语法的「过去进行式」。</p>
<blockquote>
<p>I <em>was</em> watching TV, <em>when I heard the door bell</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>听到门铃响的瞬间</em>，这是一个特定的时间段，退化为一个时间点，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态</li>
<li>这里不涉及到被动的语态，但涉及到「正在发生」的含义，所以需要用 <code>be + V-ing</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的过去形态 <code>was</code>，以及 <code>watching</code> 这个现在分词。这是传统语法的「过去进行式」。</p>
<blockquote>
<p>The witness <em>was</em> being questioned in court <em>when he had a heart attack</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>心脏病发作的瞬间</em>，这是一个特定的时间段，退化为一个时间点，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code>；同时，这里也涉及到「正在发生」的含义，所以需要用 <code>be + V-ing</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的过去形态 <code>was</code>，同时还需要 <code>being</code> 作为 <code>V-ing</code> 部分，然后还需要 <code>question</code> 的过去分词 <code>questioned</code>。这是传统语法的「过去进行式被动语态」。</p>
<h3 id=" 现在时态 ">现在时态</h3>
<blockquote>
<p>Obama <em>is</em> the U.S. President.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>几年前奥巴马上任之时到几年后奥巴马卸任之时</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段包括现在这个时间点，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们需要用 <code>is</code>。这是传统语法的「一般现在式」。</p>
<blockquote>
<p>Kyrie <em>steals</em> the ball and <em>passes</em> it to LeBron.</p>
</blockquote>
<ul>
<li>这是体育解说员在播报克利夫兰骑士队的比赛，动作发生的时间段是 <em>现在</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段包括现在这个时间点，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们分别需要用 <code>steal</code> 和 <code>pass</code> 单数第三人称形式 <code>steals</code> 和 <code>pass</code>。这是传统语法的「一般现在式」。</p>
<blockquote>
<p>All mothers <em>love</em> their children.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>无穷远的过去到无穷远的将来</em>，也就是所谓的真理，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段包括现在这个时间点，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们需要用 <code>love</code> 的原型。这是传统语法的「一般现在式」。</p>
<p>这就是为什么，传统语法说「真理要用一般现在式」。其实理解了我们的原理，就不需要被这些「特例」了。</p>
<blockquote>
<p>Walmart <em>is</em> selling big cokes at a discount <em>this mouth</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>这个月</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段包括现在这个时间点，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 <code>be + V-ing</code> 形式</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的单三形式 <code>is</code>，跟着 <code>sell</code> 的现在分词 <code>selling</code>。这是传统语法的「现在进行式」。</p>
<blockquote>
<p>According to the NASA survey, the ozone layer <em>is</em> being depleted.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>从臭氧层开始被消耗的时候到将来臭氧层不在被消耗的时候</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段包括现在这个时间点，所以应该用现在时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code>；同时，这里也涉及到「正在发生」的含义，所以需要用 <code>be + V-ing</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的单三形态 <code>is</code>，同时还需要 <code>being</code> 作为 <code>V-ing</code> 部分，然后还需要 <code>deplete</code> 的过去分词 <code>depleted</code>。这是传统语法的「现在进行式被动语态」。</p>
<h3 id=" 未来时态 ">未来时态</h3>
<blockquote>
<p>There <em>will be</em> a major election <em>in April</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>下一个四月份</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之后，所以应该用将来时态</li>
<li>这里不涉及到被动的语态，也不涉及到「正在发生」的含义，所以不需要额外的 <code>be</code></li>
</ul>
<p>因此，我们需要用 <code>will</code> 来表示将来时态，同时用 <code>be</code> 的原型，在这里表示「存在」的含义。这是传统语法的「一般将来式」。</p>
<blockquote>
<p>Don’t call me at <em>six tomorrow</em>. I <em>will</em> still <em>be</em> sleeping <em>then</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>明早六点</em>，这是一个特定的时间段，退化为一个时间点，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之后，所以应该用将来时态</li>
<li>这里不涉及到被动的语态，但不涉及到「正在发生」的含义，所以需要用 <code>be + V-ing</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>will</code> 来表示将来时态，用 <code>be</code> 动词的原型，同时接上 <code>sleep</code> 的现在分词 <code>sleeping</code>。这是传统语法的「将来进行式」。</p>
<blockquote>
<p>The building <em>will be</em> razed <em>next month</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>下个月</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之后，所以应该用将来时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code> 的形态；但不涉及到「正在发生」的含义</li>
</ul>
<p>因此，我们需要用 <code>will</code> 来表示将来时态，用 <code>be</code> 动词的原型，同时接上 <code>raze</code> 的过去分词 <code>razed</code>。这是传统语法的「一般将来式被动语态」。</p>
<h2 id=" 完成式 ">完成式</h2>
<p>完成式也有几个重要的特征：</p>
<ul>
<li><strong>完成式的动作，其发生的时间有一个明确的截止时间点，表示「在这之前」或者「至此为止」</strong></li>
<li><strong>如果这个时间点</strong><ul>
<li>是「现在」这个时间点，那么用现在时态</li>
<li>是「过去」的某个时间点，那么用过去时态</li>
<li>是「将来」的某个时间点，那么用将来时态</li>
</ul>
</li>
</ul>
<p>第一个特征，给了我们明确的信息来确定我们是否应该使用完成式（而不是简单式）。第二个特征，则为我们选择时态提供了依据。</p>
<h3 id=" 现在时态 -1">现在时态</h3>
<blockquote>
<p>I’m sure that I <em>have seen</em> this face somewhere.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点，所以应该用完成式</li>
<li>截止时间点是「现在」，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们需要用 <code>have</code> 来表示完成时态，接上 <code>see</code> 的过去分词 <code>seen</code>。这是传统语法的「现在完成式」。</p>
<blockquote>
<p>We <em>have been</em> working overtime <em>for a week</em> to fill your order.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>至今已有一周</em>），所以应该用完成式</li>
<li>截止时间点是「现在」，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 <code>be + V-ing</code> 的形式</li>
</ul>
<p>因此，我们需要用 <code>have</code> 来表示完成时态，接上 <code>be</code> 的过去分词 <code>been</code>，再加上 <code>work</code> 的现在分词 <code>working</code>。这是传统语法的「现在完成进行式」。</p>
<blockquote>
<p>The house <em>has been</em> redecorated twice since they moved in.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>从他们搬入<strong>到现在为止</strong></em>），所以应该用完成式</li>
<li>截止时间点是「现在」，所以应该用现在时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code> 的形式；但不涉及到「持续」的含义</li>
</ul>
<p>因此，我们需要用 <code>have</code> 的单三形式 <code>has</code> 来表示完成时态，接上 <code>be</code> 的过去分词 <code>been</code>，在加上 <code>redecorate</code> 的过去分词 <code>redecorated</code>。这是传统语法的「现在完成式被动语态」。</p>
<h3 id=" 过去时态 -1">过去时态</h3>
<p>一般来说，没有特别说明之时，说「在这之前」就是「在现在这个时间点之前」，所以需要用现在完成式。如果要用过去完成式，则需要有一个明确的过去时间截止点。</p>
<blockquote>
<p>Many soldiers <em>had died</em> from pneumonia <em>before the discovery of Penicilin</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>青霉素被发现之前</em>），所以应该用完成式</li>
<li>截止时间点是「过去」，所以应该用过去时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或「正在发生」的含义，所以不需要用额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们需要用 <code>have</code> 的过去式 <code>had</code> 表示过去完成式，接上 <code>die</code> 的过去分词 <code>died</code> 表示实际的动作。这是传统语法的「过去完成式」。</p>
<blockquote>
<p>I <em>had been</em> smoking three packs of cigarettes a day <em>before I decided to quit</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>我决定戒烟之前</em>），所以应该用完成式</li>
<li>截止时间点是「过去」，所以应该用过去时态</li>
<li>这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 <code>be + V-ing</code> 的形式</li>
</ul>
<p>因此，我们需要用 <code>have</code> 的过去式 <code>had</code> 表示过去完成式，接上 <code>be</code> 的过去分词 <code>been</code> 表示进行状态，最后加上 <code>smoke</code> 的现在分词 <code>smoking</code> 来表示实际的动作。这是传统语法的「过去完成进行式」。</p>
<blockquote>
<p>In the World War II, Japan <em>had not been</em> defeated yet <em>by the time Germany surrendered unconditionally</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>德国无条件投降之前</em>），所以应该用完成式</li>
<li>截止时间点是「过去」，所以应该用过去时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code> 的形式；但不涉及到「持续」或「正在发生」的含义</li>
</ul>
<p>因此，我们需要用 <code>have</code> 的过去式 <code>had</code> 表示过去完成式，接上 <code>be</code> 的过去分词 <code>been</code> 表示被动，最后加上 <code>defeat</code> 的现在分词 <code>defeated</code> 来表示实际的动作。这是传统语法的「过去完成式被动语态」。</p>
<h3 id=" 将来时态 ">将来时态</h3>
<p>和完成式的过去时态一样，将来时态中的完成式需要一个位于将来的时间截止点。</p>
<blockquote>
<p>Next April, I <em>will have worked</em> here for 2 years.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>到下个四月为止</em>），所以应该用完成式</li>
<li>截止时间点是「将来」，所以应该用将来时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或「正在发生」的含义，所以不需要用额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们需要用 <code>will have</code> 表示将来完成式，接上 <code>work</code> 的过去分词 <code>worked</code> 表示实际的动作。这是传统语法的「将来完成式」。</p>
<blockquote>
<p>Come back at 17:00. Your car <em>will have been</em> fixed <em>by then</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>下午五点之前</em>），所以应该用完成式</li>
<li>截止时间点是「将来」，所以应该用将来时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code> 的形式；但不涉及到「持续」或「正在发生」的含义</li>
</ul>
<p>因此，我们需要用 <code>will have</code> 表示将来完成式，接上 <code>be</code> 的过去分词 <code>been</code> 表示被动，再加上 <code>fix</code> 的过去分词 <code>fixed</code> 表示实际的动作。这是传统语法的「将来完成式被动语态」。</p>
<blockquote>
<p><em>In another two more minutes</em>, she <em>will have been</em> talking on the phone for three hours.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>到两分钟之后</em>），所以应该用完成式</li>
<li>截止时间点是「将来」，所以应该用将来时态</li>
<li>这里不涉及到被动的语态，但不涉及到「持续」的含义，所以需要用 <code>be + V-ing</code> 的形式</li>
</ul>
<p>因此，我们需要用 <code>will have</code> 表示将来完成式，接上 <code>be</code> 的过去分词 <code>been</code> 表示进行，再加上 <code>talk</code> 的现在分词 <code>talking</code> 表示实际的动作。这是传统语法的「将来完成进行式」。</p>
]]></content>
    <summary type="html"><![CDATA[<p>这个系列的 <a href="http://liam0205.me/2014/06/22/noun-phrase-and-articles/">上一篇文章</a> 已经快一年了。我真是懒啊……</p>
<p>中文的谓语动词不在时间、状态、语态上作区分。在中文中，这些功能由其它副词提供。在英文中，动词的形态需要根据时间、状态、语态发生改变。对于中国人来说，这样的变化确实有些不自然；选错时态也是中国人讲英文时经常犯的错误。</p>
<p>在这里，语态和说话人的态度相关，比较容易感受。同时，语态反应在动词形态上的变化也相对简单，只需要加上合适的 <code>be</code> 动词，配上动词的过去分词即可。时态和动作发生的时间相关，也相对直观。因此，如果我们能对状态做一些简化，从状态出发去讨论时态，则问题会简单得多。</p>
]]></summary>
    
      <category term="English" scheme="http://liam0205.me/tags/English/"/>
    
      <category term="Grammar" scheme="http://liam0205.me/tags/Grammar/"/>
    
      <category term="Verb" scheme="http://liam0205.me/tags/Verb/"/>
    
      <category term="Tense" scheme="http://liam0205.me/tags/Tense/"/>
    
      <category term="Literature and Social Sciences" scheme="http://liam0205.me/categories/Literature%20and%20Social%20Sciences/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 hexo new 之后立即打开新建的 Markdown 文稿]]></title>
    <link href="http://liam0205.me/2015/05/01/open-editor-after-hexo-new-immediately/"/>
    <id>http://liam0205.me/2015/05/01/open-editor-after-hexo-new-immediately/</id>
    <published>2015-05-01T01:43:35.000Z</published>
    <updated>2015-05-01T02:32:25.000Z</updated>
    <content type="html"><![CDATA[<p>自己的博客是用 Hexo 搭建的。Hexo 是其时尚为大学生的台湾人 <a href="https://github.com/tommy351" target="_blank">Tommy</a> 开发的轻量级静态博客生成器，具有简洁、快速、扩展性好等特点。</p>
<p>在 Hexo 中新建一篇博文非常简单，只需要在命令行中执行</p>
<pre><code>hexo <span class="keyword">new</span> <span class="string">"the title of your blog"</span>
</code></pre><p>即可。Hexo 会在后台自动帮你创建名为 <code>yyyy-mm-dd-the-title-of-your-blog.md</code> 的文件，供你撰写博文。不过，也有不方便的地方。通常你需要依次打开 <code>hexo-home/source/_post</code> 目录，然后在成堆的 Markdown 文件中找到刚才创建的文档。</p>
<a id="more"></a>

<hr>
<p>简单搜索之后，我发现在 Hexo 的 GitHub 项目里，有人提出了类似的需求：</p>
<p><a href="https://github.com/hexojs/hexo/issues/1007" target="_blank">https://github.com/hexojs/hexo/issues/1007</a></p>
<p>Tommy 指出，可以在 Hexo 目录下的 <code>scripts</code> 目录（若没有，则新建一个）中创建一个 JavaScript 脚本，监听 <code>hexo new</code> 这个动作。并在检测到 <code>hexo new</code> 之后，执行编辑器打开的命令。</p>
<p>Tommy 给出的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;

<span class="comment">// Hexo 2.x</span>
hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span><span class="params">(path)</span>{</span>
  spawn(<span class="string">'vi'</span>, [path]);
});

<span class="comment">// Hexo 3</span>
hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>
  spawn(<span class="string">'vi'</span>, [data.path]);
});
</pre></td></tr></table></figure>



<p>我使用的 Hexo 是 2.5.4 版本，然而，测试过 Tommy 给出的代码之后并没有顺利地打开编辑器。不过精髓已经理解，需要的就只是细节的改变了。</p>
<p>简单翻阅了一下 JavaScript 的语法规则，我尝试了下列 JavaScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;

<span class="comment">// Hexo 2.x</span>
hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span><span class="params">(path)</span>{</span>
    exec(<span class="string">'open -a "/Applications/Sublime Text.app" '</span> + path);
});
</pre></td></tr></table></figure>



<blockquote>
<p>注意，我这里执行的系统命令，是 OS X 下的 <code>open</code>。换到 Windows 中，可能需要改为 <code>start</code>。</p>
</blockquote>
<hr>
<p>在命令行中敲下</p>
<pre><code>hexo <span class="keyword">new</span> <span class="string">"open editor after hexo new immediately"</span>
</code></pre><p>之后，Sublime Text 顺利打开了相应的 Markdown 文稿。接下来的事情，就是愉快地写作啦！</p>
]]></content>
    <summary type="html"><![CDATA[<p>自己的博客是用 Hexo 搭建的。Hexo 是其时尚为大学生的台湾人 <a href="https://github.com/tommy351" target="_blank">Tommy</a> 开发的轻量级静态博客生成器，具有简洁、快速、扩展性好等特点。</p>
<p>在 Hexo 中新建一篇博文非常简单，只需要在命令行中执行</p>
<pre><code>hexo <span class="keyword">new</span> <span class="string">"the title of your blog"</span>
</code></pre><p>即可。Hexo 会在后台自动帮你创建名为 <code>yyyy-mm-dd-the-title-of-your-blog.md</code> 的文件，供你撰写博文。不过，也有不方便的地方。通常你需要依次打开 <code>hexo-home/source/_post</code> 目录，然后在成堆的 Markdown 文件中找到刚才创建的文档。</p>
]]></summary>
    
      <category term="Hexo" scheme="http://liam0205.me/tags/Hexo/"/>
    
      <category term="Markdown" scheme="http://liam0205.me/tags/Markdown/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用合适的字体回退机制（Fallback）改善网页在 Windows 平台的字体显示效果]]></title>
    <link href="http://liam0205.me/2015/04/30/using-font-fallback-to-enhance-the-appreance-on-windows/"/>
    <id>http://liam0205.me/2015/04/30/using-font-fallback-to-enhance-the-appreance-on-windows/</id>
    <published>2015-04-30T09:18:40.000Z</published>
    <updated>2015-05-01T13:33:55.000Z</updated>
    <content type="html"><![CDATA[<p>昨天在群里提起 Windows 平台下坑爹的中易宋体之屏显效果，今日忽而想起自己的博客在 Windows 平台下显示的也是宋体。当然，这不是我的错。原本的字体机制，博客会按照顺序选择一款无衬线字体，直到无可选择时采用系统默认的无衬线字体。但是坑死人不偿命的云都死系统，把 SimSun （中易宋体）这个带有衬线（好吧，严格来说中文没有这个概念，我们跟着西文勉强这么称呼它）的字体也放进了系统 sans serif 字族里面去。其结果就是，不能丑陋更多。</p>
<p>作为一个强迫症患者，我们来看看如何修复这个问题。</p>
<a id="more"></a>

<h2 id=" 字体选择 ">字体选择</h2>
<p>配置字体回退机制，两个主要的原则就是：</p>
<ul>
<li>屏显效果好的字体放前面</li>
<li>适用范围小的字体放前面</li>
</ul>
<p>两条原则共同的作用就是：在尽可能多的平台下，获得相对更好的字体屏显效果。</p>
<p>对于中文来说，安装在作业系统中的主流黑体，屏显效果有大致如下的排序：</p>
<ul>
<li>Hiragino Sans GB - 冬青黑体</li>
<li>Source Han Sans CN - 思源黑体</li>
<li>Microsoft YaHei - 微软雅黑 (On Windows)</li>
<li>STXihei - 华文细黑</li>
<li>WenQuanYi Micro Hei - 文泉驿米黑</li>
<li>SimHei - 中易黑体</li>
</ul>
<p>其中冬青黑体和华文细黑，默认安装在 OS X 作业系统上；微软雅黑和中易黑体则主要安装在 Windows 作业系统上；思源黑体和文泉驿米黑则是 Linux 系统的主流中文黑体。</p>
<p>参考这一屏显效果排序，再结合一些实际情况（比如，在 OS X 作业系统中可能会因为安装 MS Office 而获得微软雅黑和中易宋体），我们给出了这样一个字体回退机制：</p>
<ol>
<li>Hiragino Sans GB</li>
<li>STXihei</li>
<li>Source Han Sans CN</li>
<li>Microsoft YaHei</li>
<li>WenQuanYi Micro Hei</li>
<li>SimHei</li>
</ol>
<p>这样，再加上西文的字体和系统默认的 <code>sans serif</code>，我们就得到了完整的字体回退列表：</p>
<pre><code>font<span class="attribute">-sans</span> <span class="subst">=</span> <span class="string">"Helvetica Neue"</span>, <span class="string">"Helvetica"</span>, <span class="string">"Hiragino Sans GB"</span>, <span class="string">"Source Han Sans CN"</span>, <span class="string">"STXihei"</span>, <span class="string">"Microsoft YaHei"</span>, <span class="string">"WenQuanYi Micro Hei"</span>, <span class="string">"SimHei"</span>, <span class="string">"Arial"</span>, sans<span class="attribute">-serif</span>
</code></pre><h2 id=" 修改 _modernist_ 主题的字体回退配置 ">修改 <code>modernist</code> 主题的字体回退配置</h2>
<p>网页的字体回退机制一般写在样式表（CSS）文件中。<code>hexo</code> 的样式表文件是从一些 <code>styl</code> 文件中产生的，每一个主题的 <code>styl</code> 文件结构都不大一样，所以这篇文章以我使用的 <code>modernist</code> 为准讲述。</p>
<p><code>modernist</code> 的作者很有心，将一些可能需要个性化配置的变量专门储存在名为 <code>variable.styl</code> 的文件里。这个文件位于 <code>./theme/modernist/source/css/_base/variable.styl</code>，我们打开它，然后将 <code>font-default</code> 和 <code>font-title</code> 的值改为：</p>
<pre><code><span class="string">"Helvetica Neue"</span>, <span class="string">"Helvetica"</span>, <span class="string">"Hiragino Sans GB"</span>, <span class="string">"Source Han Sans CN"</span>, <span class="string">"STXihei"</span>, <span class="string">"Microsoft YaHei"</span>, <span class="string">"WenQuanYi Micro Hei"</span>, <span class="string">"SimHei"</span>, <span class="string">"Arial"</span>, sans<span class="attribute">-serif</span>
</code></pre><p>之后，我们在命令行运行</p>
<pre><code>hexo clean <span class="subst">&amp;&amp;</span> hexo d <span class="attribute">-g</span>
</code></pre><p>就能将修复好的 CSS 文件推送到仓库了。</p>
<p>之后在 Windows 中打开，就会依照上述字体顺序去检索字体。对于新版的 Windows 系统，一般会以微软雅黑打开；对于旧版的 Windows 字体，一般会以中易黑体打开。</p>
]]></content>
    <summary type="html"><![CDATA[<p>昨天在群里提起 Windows 平台下坑爹的中易宋体之屏显效果，今日忽而想起自己的博客在 Windows 平台下显示的也是宋体。当然，这不是我的错。原本的字体机制，博客会按照顺序选择一款无衬线字体，直到无可选择时采用系统默认的无衬线字体。但是坑死人不偿命的云都死系统，把 SimSun （中易宋体）这个带有衬线（好吧，严格来说中文没有这个概念，我们跟着西文勉强这么称呼它）的字体也放进了系统 sans serif 字族里面去。其结果就是，不能丑陋更多。</p>
<p>作为一个强迫症患者，我们来看看如何修复这个问题。</p>
]]></summary>
    
      <category term="Hexo" scheme="http://liam0205.me/tags/Hexo/"/>
    
      <category term="Fonts" scheme="http://liam0205.me/tags/Fonts/"/>
    
      <category term="Fallback" scheme="http://liam0205.me/tags/Fallback/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Git 中 Checkout 历史版本]]></title>
    <link href="http://liam0205.me/2015/04/29/git-checkout-history-version/"/>
    <id>http://liam0205.me/2015/04/29/git-checkout-history-version/</id>
    <published>2015-04-29T00:44:56.000Z</published>
    <updated>2015-04-29T01:59:31.000Z</updated>
    <content type="html"><![CDATA[<p>昨天写代码的时候，误删了一个文件。今天发现的时候，commit 已经 push 到版本库了。本想用 <code>git reset</code> 回退版本，找回文件后重新提交。但是想起 Git 是一个版本控制系统哎，直接从版本库里 checkout 出某个文件的历史版本不就好了？</p>
<p>想法挺好，但是很久没用这个功能，自己已经不记得具体的命令了。于是查了下手册，把和 checkout 历史版本有关的几个命令都记录一下。</p>
<a id="more"></a>

<h3 id=" 从某个历史版本创建新的分支 ">从某个历史版本创建新的分支</h3>
<p>在 Git 中从当前分支创建并检出新分支的命令是</p>
<pre><code>git checkout <span class="attribute">-b</span> name<span class="attribute">-of</span><span class="attribute">-new</span><span class="attribute">-branch</span>
</code></pre><p>这个命令实际上是</p>
<pre><code>git checkout <span class="attribute">-b</span> name<span class="attribute">-of</span><span class="attribute">-new</span><span class="attribute">-branch</span> current<span class="attribute">-branch</span>
</code></pre><p>的简写形式。也就是说，当我们不指定 checkout 起点时，Git 默认从当前活动分支开始创建新的分支。</p>
<p>Git 的每个提交都有一个 SHA1 散列值（Hash 值）作为 ID。我们可以在 <code>checkout</code> 命令中使用这些 ID 作为起点。比如：</p>
<pre><code>git checkout <span class="attribute">-b</span> name<span class="attribute">-of</span><span class="attribute">-new</span><span class="attribute">-branch</span> <span class="number">169</span>d2dc
</code></pre><p>这样，Git 的活动分支会切换到 <code>name-of-new-branch</code> 这个分支上，而它的内容与 <code>169d2dc</code> 这个分支一致。</p>
<p>注意：SHA1 的散列值有 40 个字母，相当长。所以 Git 允许我们在不引起歧义的情况下，使用散列值的前几位作为缩写。</p>
<p>提示：你也可以用 <code>git branch name-of-new-branch 169d2dc</code> 来创建一个历史分支，而不切换到该分支。</p>
<h3 id=" 将某个历史版本 _checkout_ 到工作区 ">将某个历史版本 checkout 到工作区</h3>
<p>首先说明，这样做会产生一个分离的 HEAD 指针，所以个人不推荐这么做。</p>
<p>如果我们工作在 <code>master</code> 分支上，希望 checkout 到 <code>dev</code> 分支上，我们会这么做：</p>
<pre><code>git checkout dev
</code></pre><p>这里 <code>dev</code> 实际上是一个指针的别名，其本质也是一个 SHA1 散列值。所以，我们很自然地可以用</p>
<pre><code>git checkout <span class="subst">&lt;</span>sha1<span class="attribute">-of</span><span class="attribute">-a</span><span class="attribute">-commit</span><span class="subst">&gt;</span>
</code></pre><p>将某个历史版本 checkout 到工作区。</p>
<h3 id=" 将某个文件的历史版本 _checkout_ 到工作区 ">将某个文件的历史版本 checkout 到工作区</h3>
<p>大多数时候，我们可能只需要对某一个文件做细小的修补，因此只 checkout 该文件就行了，并不需要操作整个 commit 或分支。</p>
<p>上一节我们介绍了如何将某个历史版本完整地 checkout 到工作区。实际上，我们只需要在上一节的命令之后加上需要 checkout 的文件即可。</p>
<pre><code>git checkout &lt;sha1-<span class="operator">of</span>-<span class="operator">a</span>-commit&gt; &lt;/path/<span class="built_in">to</span>/your/<span class="built_in">file</span>&gt;
</code></pre><p>当然，有时候你需要将某个文件的历史版本 checkout 出来，并以一个新的名字保存。这时候可以这么做：</p>
<pre><code>git checkout &lt;sha1-of-a-commit&gt;<span class="symbol">:&lt;/path/to/your/file&gt;</span> &lt;<span class="regexp">/new/name</span><span class="regexp">/of/the</span><span class="regexp">/file&gt;</span>
</code></pre>]]></content>
    <summary type="html"><![CDATA[<p>昨天写代码的时候，误删了一个文件。今天发现的时候，commit 已经 push 到版本库了。本想用 <code>git reset</code> 回退版本，找回文件后重新提交。但是想起 Git 是一个版本控制系统哎，直接从版本库里 checkout 出某个文件的历史版本不就好了？</p>
<p>想法挺好，但是很久没用这个功能，自己已经不记得具体的命令了。于是查了下手册，把和 checkout 历史版本有关的几个命令都记录一下。</p>
]]></summary>
    
      <category term="Git" scheme="http://liam0205.me/tags/Git/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Apple 词典·再要你命 3000 | 美国传统大辞典 | Merriam Webster Collegiate Dict]]></title>
    <link href="http://liam0205.me/2015/04/24/apple-dictionaries-download/"/>
    <id>http://liam0205.me/2015/04/24/apple-dictionaries-download/</id>
    <published>2015-04-24T03:14:08.000Z</published>
    <updated>2015-04-28T23:42:40.000Z</updated>
    <content type="html"><![CDATA[<p>Apple 为 OS X 设计的词典非常好用，在不进行任何配置的情况下，就可以在全系统范围内进行选词查询。遗憾的是，Apple 并没有为用户提供太多可选的词典。</p>
<p>我用 Python 写了一个程序，将 Babylon 词典软件的 BGL 格式，转换为 Apple Dictionaries 的格式。由于 Babylon 的词典众多，于是 Apple 自带的词典也就多了起来。</p>
<a id="more"></a>

<p>这里转换好的有五个词典：</p>
<ul>
<li>再要你命 3000</li>
<li>美国传统大词典 英汉双解版</li>
<li>柯林斯高阶英汉双解学习词典</li>
<li>美林韦氏大学词典</li>
<li>英汉数学名词词典</li>
<li>英语用法词典</li>
</ul>
<p>下载后，将 ZIP 归档解包，将得到的 .dictionary 文件（实际上是文件夹）移动到下列目录：</p>
<pre><code>~<span class="regexp">/Library/</span><span class="constant">Dictionaries</span>
</code></pre><p>打开系统里的词典程序，在配置中，就能看到新增的词典了。</p>
<p>下载链接: <a href="http://pan.baidu.com/s/1gdIgK0b" target="_blank">http://pan.baidu.com/s/1gdIgK0b</a><br>提取密码: nsp0</p>
<p>文章已转载至知乎：<a href="http://www.zhihu.com/question/27098318/answer/46110189" target="_blank">http://www.zhihu.com/question/27098318/answer/46110189</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>Apple 为 OS X 设计的词典非常好用，在不进行任何配置的情况下，就可以在全系统范围内进行选词查询。遗憾的是，Apple 并没有为用户提供太多可选的词典。</p>
<p>我用 Python 写了一个程序，将 Babylon 词典软件的 BGL 格式，转换为 Apple Dictionaries 的格式。由于 Babylon 的词典众多，于是 Apple 自带的词典也就多了起来。</p>
]]></summary>
    
      <category term="3000" scheme="http://liam0205.me/tags/3000/"/>
    
      <category term="AHD" scheme="http://liam0205.me/tags/AHD/"/>
    
      <category term="Merriam Webster" scheme="http://liam0205.me/tags/Merriam%20Webster/"/>
    
      <category term="Apple Dictionaries" scheme="http://liam0205.me/tags/Apple%20Dictionaries/"/>
    
      <category term="GRE" scheme="http://liam0205.me/categories/GRE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PIL 简明教程 - 基本用法]]></title>
    <link href="http://liam0205.me/2015/04/22/pil-tutorial-basic-usage/"/>
    <id>http://liam0205.me/2015/04/22/pil-tutorial-basic-usage/</id>
    <published>2015-04-22T09:46:31.000Z</published>
    <updated>2015-05-24T04:59:12.000Z</updated>
    <content type="html"><![CDATA[<p>PIL (Python Image Library) 是 Python 平台处理图片的事实标准，兼具强大的功能和简洁的 API。这篇文章将从 PIL 的安装开始，介绍 PIL 的基本情况和基本用法。</p>
<p>系列文章列表：</p>
<ol>
<li><a href="/2015/04/22/pil-tutorial-basic-usage/">基本用法</a></li>
<li><a href="/2015/05/05/pil-tutorial-imagedraw-and-imagefont/"><code>ImageDraw</code> 和 <code>ImageFont</code> 模块</a></li>
</ol>
<a id="more"></a>

<h2 id=" 安装 ">安装</h2>
<p>虽然本篇介绍的是 PIL，但实际上安装的却是 Pillow。PIL 的更新速度很慢，而且存在一些难以配置的问题，不推荐使用；而 Pillow 库则是 PIL 的一个分支，维护和开发活跃，Pillow 兼容 PIL 的绝大多数语法，推荐使用。</p>
<p>在安装 Pillow 之前，需要安装好一些开源库。对于 Mac OS X 而言，可以用 HomeBrew 来安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="built_in">sudo</span> chown -R <span class="variable">$USER</span>:admin /usr/local
brew install libtiff libjpeg libpng webp little-cms2 freetype
<span class="built_in">sudo</span> pip install Pillow
</pre></td></tr></table></figure>



<p>安装好之后，打开 Python 解释器，输入 <code>from PIL import Image</code> 来测试是否安装成功。</p>
<h2 id=" 新建一个 _Image_ 类的实例 ">新建一个 <code>Image</code> 类的实例</h2>
<p>PIL 的主要功能定义在 <code>Image</code> 类当中，而 <code>Image</code> 类定义在同名的 <code>Image</code> 模块当中。使用 PIL 的功能，一般都是从新建一个 <code>Image</code> 类的实例开始。新建 <code>Image</code> 类的实例有多种方法。你可以用 <code>Image</code> 模块的 <code>open()</code> 函数打开已有的图片档案，也可以处理其它的实例，或者从零开始构建一个实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">from</span> PIL <span class="keyword">import</span> Image
sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
</pre></td></tr></table></figure>



<p>上述代码引入了 Image 模块，并以 <code>open()</code> 方法打开了 <code>source.png</code> 这个图像，构建了名为 <code>avatar</code> 的实例。如果打开失败，则会抛出 <code>IOError</code> 异常。</p>
<p>接下来你可以使用 <code>show()</code> 方法来查看实例。注意，PIL 会将实例暂存为一个临时文件，而后打开它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>avatar.show()
</pre></td></tr></table></figure>



<p><img src="/attachment/images/Python/pil-tutorial/Image_show.png" alt=" 使用 `show()` 方法查看实例的内容 "></p>
<h2 id=" 查看实例的属性 ">查看实例的属性</h2>
<p><code>Image</code> 类的实例有 5 个属性，分别是：</p>
<ul>
<li><code>format</code>: 以 <code>string</code> 返回图片档案的格式（<code>JPG</code>, <code>PNG</code>, <code>BMP</code>, <code>None</code>, etc.）；如果不是从打开文件得到的实例，则返回 <code>None</code>。</li>
<li><code>mode</code>: 以 <code>string</code> 返回图片的模式（RGB, CMYK, etc.）；完整的列表参见 <a href="http://effbot.org/imagingbook/concepts.htm#mode" target="_blank">官方说明·图片模式列表</a></li>
<li><code>size</code>: 以二元 tuple 返回图片档案的尺寸 (width, height)</li>
<li><code>palette</code>: 仅当 <code>mode</code> 为 <code>P</code> 时有效，返回 <code>ImagePalette</code> 示例</li>
<li><code>info</code>: 以字典形式返回示例的信息</li>
</ul>
<p>我们接着上面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">print</span> avatar.format, avatar.size, avatar.mode
</pre></td></tr></table></figure>



<p><img src="/attachment/images/Python/pil-tutorial/Image_attrib.png" alt=" 查看示例的属性 "></p>
<p>这里我们看到返回了图片的格式 <code>PNG</code>、图片的大小 <code>(400, 400)</code> 和图片的模式 <code>RGB</code>。</p>
<h2 id=" 实例的方法 ">实例的方法</h2>
<p><code>Image</code> 类定义了许多方法，这里无法一一列出（也无必要）。如果有需要，可以参看 <a href="http://effbot.org/imagingbook/image.htm" target="_blank">官方说明·<code>Image</code> 模块</a>。这里仅列出几个有趣的应用。</p>
<h3 id=" 图片 _IO_-_ 转换图片格式 ">图片 IO - 转换图片格式</h3>
<p><code>Image</code> 模块提供了 <code>open()</code> 函数打开图片档案，<code>Image</code> 类则提供了 <code>save()</code> 方法将图片实例保存为图片档案。</p>
<p><code>save()</code> 函数可以以特定的图片格式保存图片档案。比如 <code>save(&#39;target.jpg&#39;, &#39;JPG&#39;)</code> 将会以 <code>JPG</code> 格式将图片示例保存为 <code>target.jpg</code>。不过，大多数时候也可以省略图片格式。此时，<code>save()</code> 方法会根据文件扩展名来选择相应的图片格式。</p>
<p>我们以一个转换图片格式的脚本进行分析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">import</span> os, sys
<span class="keyword">from</span> PIL <span class="keyword">import</span> Image

<span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:
    f, e = os.path.splitext(infile)
    outfile = f + <span class="string">".jpg"</span>
    <span class="keyword">if</span> infile != outfile:
        <span class="keyword">try</span>:
            Image.open(infile).save(outfile)
        <span class="keyword">except</span> IOError:
            <span class="keyword">print</span> <span class="string">"cannot convert"</span>, infile
</pre></td></tr></table></figure>



<p>这里，<code>f</code> 是除去扩展名之外的文件名。在 <code>try</code> 语句中，我们尝试打开图片档案，然后以 <code>.jpg</code> 为扩展名保存图片档案。<code>save()</code> 方法会根据扩展名，将图片以 <code>JPG</code> 格式保存为档案。如果图片档案无法打开，则在终端上打印无法转换的消息。</p>
<h3 id=" 制作缩略图 ">制作缩略图</h3>
<p><code>Image</code> 类的 <code>thumbnail()</code> 方法可以用来制作缩略图。它接受一个二元数组作为缩略图的尺寸，然后将示例缩小到指定尺寸。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">import</span> os, sys
<span class="keyword">from</span> PIL <span class="keyword">import</span> Image

<span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:
    outfile = os.path.splitext(infile)[<span class="number">0</span>] + <span class="string">".thumbnail"</span>
    <span class="keyword">if</span> infile != outfile:
        <span class="keyword">try</span>:
            im   = Image.open(infile)
            x, y = im.size
            im.thumbnail((x//<span class="number">2</span>, y//<span class="number">2</span>))
            im.save(outfile, <span class="string">"JPEG"</span>)
        <span class="keyword">except</span> IOError:
            <span class="keyword">print</span> <span class="string">"cannot create thumbnail for"</span>, infile
</pre></td></tr></table></figure>



<p>这里我们用 <code>im.size</code> 获取原图档的尺寸，然后以 <code>thumbnail()</code> 制作缩略图，大小则是原先图档的四分之一。同样，如果图档无法打开，则在终端上打印无法执行的提示。</p>
<h3 id=" 剪裁图档 ">剪裁图档</h3>
<p>以前也写过 <a href="http://liam0205.me/2014/01/27/Py-Incise-Images/">一篇博客</a>，讲述如何用 PIL 批量剪裁图档，供参考。</p>
<h3 id=" 变形与粘贴 ">变形与粘贴</h3>
<p><code>transpose()</code> 方法可以将图片左右颠倒、上下颠倒、旋转 90°、旋转 180° 或旋转 270°。<code>paste()</code> 方法则可以将一个 <code>Image</code> 示例粘贴到另一个 <code>Image</code> 示例上。</p>
<p>我们尝试将一张图片的左半部分截取下来，左右颠倒之后旋转 180°；将图片的右半边不作更改粘贴到左半部分；最后将修改过的左半部分粘贴到右半部分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">from</span> PIL <span class="keyword">import</span> Image

imageFName = <span class="string">'source.png'</span>

<span class="function"><span class="keyword">def</span> <span class="title">iamge_transpose</span><span class="params">(image)</span>:</span>
    <span class="string">'''
        Input: a Image instance
        Output: a transposed Image instance
        Function:
            * switches the left and the right part of a Image instance
            * for the left part of the original instance, flips left and right\
                and then make it upside down.
    '''</span>
    xsize, ysize = image.size
    xsizeLeft    = xsize // <span class="number">2</span> <span class="comment"># while xsizeRight = xsize - xsizeLeft</span>

    boxLeft      = (<span class="number">0</span>, <span class="number">0</span>, xsizeLeft, ysize)
    boxRight     = (xsizeLeft, <span class="number">0</span>, xsize, ysize)
    boxLeftNew   = (<span class="number">0</span>, <span class="number">0</span>, xsize - xsizeLeft, ysize)
    boxRightNew  = (xsize - xsizeLeft, <span class="number">0</span>, xsize, ysize)

    partLeft     = image.crop(boxLeft).transpose(Image.FLIP_LEFT_RIGHT).\
        transpose(Image.ROTATE_180)
    partRight    = image.crop(boxRight)

    image.paste(partRight, boxLeftNew)
    image.paste(partLeft, boxRightNew)
    <span class="keyword">return</span> image

avatar = Image.open(imageFName)
avatar = iamge_transpose(avatar)
avatar.show()
</pre></td></tr></table></figure>



<p><code>image_transpose()</code> 函数定义之前的部分很简单，而函数本身也由文档叙述得比较清楚。</p>
<p>这里我们以 <code>xsize</code> 和 <code>ysize</code> 接收图片的宽和高，然后以 <code>xsizeLeft</code> 计算得到左半边图片的大小。需要注意的是，我们构建了四个元组，并命名为盒子。这个盒子用直角坐标的值在 <code>image</code> 的画布上框定了一个区域。注意，<code>Image</code> 模块以图片的左上角为直角坐标原点，向右为 <code>x</code> 轴正方向，向下为 <code>y</code> 轴正方向。元组中的前两个数，代表区域左上角的坐标值；后两个数代表区域右下角的坐标值。</p>
<p>接下来的代码相当易懂。我们先用 <code>crop()</code> 方法将原图 <code>boxLeft</code> 的区域（也就是原图的左半边）切下来，然后用 <code>transpose()</code> 方法先后进行左右颠倒和旋转 180° 的工作，并最周公将它保存在 <code>partLeft</code> 这个实例中。而 <code>partRight</code> 的操作更为简单。</p>
<p>函数的最后，我们用 <code>paste()</code> 方法，将前两步得到的 <code>partLeft</code> 和 <code>partRight</code> 分别粘贴到指定的区域；并最终返回 <code>image</code> 示例。</p>
<p>代码片段的最后，我们用 <code>show()</code> 方法展示图片。</p>
<p><img src="/attachment/images/Python/pil-tutorial/transpose_paste.png" alt=" 变形和旋转 "></p>
]]></content>
    <summary type="html"><![CDATA[<p>PIL (Python Image Library) 是 Python 平台处理图片的事实标准，兼具强大的功能和简洁的 API。这篇文章将从 PIL 的安装开始，介绍 PIL 的基本情况和基本用法。</p>
<p>系列文章列表：</p>
<ol>
<li><a href="/2015/04/22/pil-tutorial-basic-usage/">基本用法</a></li>
<li><a href="/2015/05/05/pil-tutorial-imagedraw-and-imagefont/"><code>ImageDraw</code> 和 <code>ImageFont</code> 模块</a></li>
</ol>
]]></summary>
    
      <category term="Python" scheme="http://liam0205.me/tags/Python/"/>
    
      <category term="PIL" scheme="http://liam0205.me/tags/PIL/"/>
    
      <category term="Image" scheme="http://liam0205.me/tags/Image/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[避免 \chapter 命令分页]]></title>
    <link href="http://liam0205.me/2015/04/22/cancle-clearpage-in-chapter/"/>
    <id>http://liam0205.me/2015/04/22/cancle-clearpage-in-chapter/</id>
    <published>2015-04-22T01:39:26.000Z</published>
    <updated>2015-04-22T02:14:27.000Z</updated>
    <content type="html"><![CDATA[<p>LaTeX 的 <code>book</code> 类中，<code>\chapter</code> 命令用来标记章节。在生成的 PDF 文稿中，<code>\chapter</code> 总是另起一页；在打开（默认）<code>openright</code> 选项的时候，可能还会空白一页。在实际使用过程中，很多人希望 <code>\chapter</code> 不要换页，紧接着当前页的内容排版。</p>
<p>传统工具没有提供此功能，因此用户需要自行修改 <code>\chapter</code> 的定义。</p>
<a id="more"></a>

<h2 id=" 找到 _\chapter_ 的定义 ">找到 <code>\chapter</code> 的定义</h2>
<p>LaTeX 标准文档类的定义写在 <code>classes.pdf</code> 这个文档中，你可以在命令行下使用 <code>texdoc classes</code> 来打开这份文档。</p>
<p>你可以在文档的 7.2.6 节中找到 <code>\chapter</code> 的定义。和我们的问题相关的，就是 <code>\chapter</code> 定义的第一行。</p>
<p><img src="/images/LaTeX/def-of-chapter.png" alt="`\chapter` 的定义 "></p>
<p>得益于 <a href="http://liam0205.me/2015/01/23/literate-programming-in-latex/">文学编程</a>，我们看到文档中明确地写着「章节总是应该从新的一页开始，因此我们需要调用 <code>\clearpage</code>」。</p>
<p>显然，为了达到目的，我么只需要令 <code>\chapter</code> 定义的第一行失效就好了。</p>
<h2 id=" 打补丁 ">打补丁</h2>
<p><code>xpatch</code> 宏包可以用来打补丁。它的 <code>\xpatchcmd</code> 命令接受五个参数：<code>\xpatchcmd{命令}{搜索}{替换}{成功}{失败}</code></p>
<ul>
<li><code>命令</code>：待处理的命令</li>
<li><code>搜索</code>：需要被替换的部分</li>
<li><code>替换</code>：将被替换的内容</li>
<li><code>成功</code>：替换成功执行的内容</li>
<li><code>失败</code>：替换失败执行的内容</li>
</ul>
<p>这里我们需要将 <code>\if@openright\cleardoublepage\else\clearpage\fi</code> 替换掉。用于替换的内容则是：<code>\par\relax</code>。因此我们有代码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="command">\usepackage</span><span class="special">{</span>xpatch<span class="special">}</span>
<span class="command">\makeatletter</span>
<span class="command">\xpatchcmd</span><span class="special">{</span><span class="command">\chapter</span><span class="special">}</span>
  <span class="special">{</span><span class="command">\if</span>@openright<span class="command">\cleardoublepage</span><span class="command">\else</span><span class="command">\clearpage</span><span class="command">\fi</span><span class="special">}</span><span class="special">{</span><span class="command">\par</span><span class="command">\relax</span><span class="special">}</span>
  <span class="special">{</span><span class="special">}</span><span class="special">{</span><span class="special">}</span>
<span class="command">\makeatother</span>
</pre></td></tr></table></figure>



<p>注意，符号 <code>@</code> 是一个保留符号。它在用户编写 <code>.tex</code> 文档的时候和开发者编写宏包 / 文档类的时候具有不同含义。我们用 <code>\makeatletter</code> 将 <code>@</code> 的含义切换到开发者模式；在进行修改之后，用 <code>\makeatother</code> 将 <code>@</code> 的含义切换到用户模式。</p>
<p>这样，<code>\chapter</code> 定义中的换行部分，就被替换成了分段。</p>
<p>完整的示例代码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>book<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>xpatch<span class="special">}</span>
<span class="command">\makeatletter</span>
<span class="command">\xpatchcmd</span><span class="special">{</span><span class="command">\chapter</span><span class="special">}</span>
  <span class="special">{</span><span class="command">\if</span>@openright<span class="command">\cleardoublepage</span><span class="command">\else</span><span class="command">\clearpage</span><span class="command">\fi</span><span class="special">}</span><span class="special">{</span><span class="command">\par</span><span class="command">\relax</span><span class="special">}</span>
  <span class="special">{</span><span class="special">}</span><span class="special">{</span><span class="special">}</span>
<span class="command">\makeatother</span>
<span class="command">\usepackage</span><span class="special">{</span>blindtext<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\blindtext</span>
<span class="command">\chapter</span><span class="special">{</span>test<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>


]]></content>
    <summary type="html"><![CDATA[<p>LaTeX 的 <code>book</code> 类中，<code>\chapter</code> 命令用来标记章节。在生成的 PDF 文稿中，<code>\chapter</code> 总是另起一页；在打开（默认）<code>openright</code> 选项的时候，可能还会空白一页。在实际使用过程中，很多人希望 <code>\chapter</code> 不要换页，紧接着当前页的内容排版。</p>
<p>传统工具没有提供此功能，因此用户需要自行修改 <code>\chapter</code> 的定义。</p>
]]></summary>
    
      <category term="Chapter" scheme="http://liam0205.me/tags/Chapter/"/>
    
      <category term="Pagebreak" scheme="http://liam0205.me/tags/Pagebreak/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 MacTeX 中使用中文模板]]></title>
    <link href="http://liam0205.me/2015/04/14/using-chinese-templates-in-mactex/"/>
    <id>http://liam0205.me/2015/04/14/using-chinese-templates-in-mactex/</id>
    <published>2015-04-14T09:52:30.000Z</published>
    <updated>2015-04-14T11:54:37.000Z</updated>
    <content type="html"><![CDATA[<p>中国人使用 LaTeX 的一大问题就是为文档添加中文支持。国内很多学校、期刊都有自己的模板，更多的是一些个人配置的勉强成型的小模板。Mac 用户安装 MacTeX 之后，可能会很头疼如何将这些模板移植到自己的电脑上。这篇文章对此做一个方法上的讨论。</p>
<a id="more"></a>

<p>在 LaTeX 中使用中文，<strong>不严谨地说</strong>，主要需要解决编码和字体调用的问题。</p>
<p>国内 LaTeX 圈子流行过 GBK 编码和 UTF-8 编码。前者是国标，是过去的主流，但是问题多多。现在推荐使用后者。</p>
<p>字体调用方面，原来的 <code>CCT</code>（新版）、<code>CJK</code> 还有现在的 <code>xeCJK</code>、<code>LuaTeX-ja</code> 和李阿玲的 pTeX-ng 在 TeX Live（MacTeX）底下都能正常工作。只不过，Mac 默认的字体和 Windows 默认的字体有一些不同，在这方面需要做一些调整。</p>
<p>国内期刊的模板大多数是 <code>CCT</code> 和 <code>CJK</code> 方式，其他一些模板可能比较先进，使用 <code>xeCJK</code> 方式。<code>LuaTeX-ja</code> 国内用的少，使用方法和 <code>xeCJK</code> 比较类似；pTeX-ng 尚在开发中。所以这里只介绍使用 <code>CCT</code>、<code>CJK</code> 或 <code>xeCJK</code> 三种中文支持方式在 TeX Live 里如何进行调整。</p>
<h2 id="xeCJK"><code>xeCJK</code></h2>
<p><code>xeCJK</code> 通过 <code>\setCJKmainfont</code> 等命令（<code>luatexja-fontspec</code> 则是 <code>\setmainjfont</code>）来调用操作系统内的字体，并设置为文档字体。在 Windows 底下编写的中文模板，惯常使用 Windows 自带的中易系列字体，比如</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="command">\setCJKmainfont</span><span class="special">[</span>Boldfont = SimHei, ItalicFont = KaiTi<span class="special">]</span><span class="special">{</span>SimSun<span class="special">}</span>
<span class="command">\setCJKsansfont</span><span class="special">{</span>SimHei<span class="special">}</span>
<span class="command">\setCJKmonofont</span><span class="special">{</span>FangSong<span class="special">}</span>
</pre></td></tr></table></figure>



<p>这种情况下，可以打开模板文件（<code>.tex</code>、<code>.sty</code> 或 <code>.cls</code>），找到字体设置部分，将其内容改为 Mac 的字体设置即可。比如可以参考配置：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="command">\setCJKmainfont</span><span class="special">[</span>BoldFont=STZhongsong, ItalicFont=STKaiti<span class="special">]</span><span class="special">{</span>STSong<span class="special">}</span>
<span class="command">\setCJKsansfont</span><span class="special">[</span>BoldFont=STHeiti<span class="special">]</span><span class="special">{</span>STXihei<span class="special">}</span>
<span class="command">\setCJKmonofont</span><span class="special">{</span>STFangsong<span class="special">}</span>
</pre></td></tr></table></figure>



<p>具体的含义可参考：<a href="http://liam0205.me/2014/11/02/latex-mactex-chinese-support/">为 MacTeX 配置中文支持</a></p>
<p>使用 <code>xeCJK</code> 的模板，应该都保存为 UTF-8 编码，所以不需要进行编码调整。<br>（部分模板使用 GBK 编码，在文档头会有 <code>\XeTeXinputencoding &#39;CP936&#39;</code> 的 XeTeX 原语。此时最好将文件另存为 UTF-8 编码，并删除这些原语。）</p>
<h2 id="CJK"><code>CJK</code></h2>
<p>在不适用 <code>zhmetrics</code> 技术的时候，<code>CJK</code> 需要 Type 1 字体。将中易字体拆分成许多 sub-fonts 并转换为 Type 1 字体是个费时费力的工作。CTeX 套装打包了已经配置好的 CJK 字体，它的 song、hei、kai、fs、li 和 you 等六套字体，流传甚广。国内使用 <code>CJK</code> 的模板，大都使用了这几套字体。</p>
<p>不过，<code>CJK</code> 宏包本身并不含有这些字体，所以在使用 TeX Live 的时候，直接编译这些模板会报错。</p>
<p>我们看一段最简单的使用 <code>CJK</code> 宏包做中文支持的例子。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>article<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>CJKutf8<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>CJK*<span class="special">}</span><span class="special">{</span>UTF8<span class="special">}</span><span class="special">{</span>song<span class="special">}</span>
中文。
<span class="command">\clearpage</span>
<span class="command">\end</span><span class="special">{</span>CJK*<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>对于 Windows 系统的 TeX Live 用户而言，最简单的办法是使用 <code>zhmetrics</code> 技术。为此我们只需要在导言区添加一行命令即可，代码变为：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>article<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>CJKutf8<span class="special">}</span>
<span class="command">\AtBeginDvi</span><span class="special">{</span><span class="command">\input</span><span class="special">{</span>zhwinfonts<span class="special">}</span><span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>CJK*<span class="special">}</span><span class="special">{</span>UTF8<span class="special">}</span><span class="special">{</span>song<span class="special">}</span>
中文。
<span class="command">\clearpage</span>
<span class="command">\end</span><span class="special">{</span>CJK*<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>此时，使用 pdfLaTeX 或 LaTeX - DVIPDFMx 编译文档，即可得到正确的结果。</p>
<p>对于 Mac/Linux 系统的 TeX Live（MacTeX）用户而言，简单地加载 <code>zhwinfonts.tex</code> 是不会奏效的。<code>zhwinfonts.tex</code> 是为 Windows 系统配置的文件，在 Mac/Linux 系统中缺少这些字体。我自己买了方正系列字体在 Mac 上使用，所以写了一个 <code>zhfzfonts.tex</code> 来调用这些字体。</p>
<p>需要做的事情：</p>
<ol>
<li>安装下列字体（涉及到版权，这里就不提供了）<ul>
<li>方正书宋 GBK：FZSSK.TTF</li>
<li>方正楷体 GBK：FZKTK.TTF</li>
<li>方正黑体 GBK：FZHTK.TTF</li>
<li>方正仿宋 GBK：FZFSK.TTF</li>
<li>华文隶体：STLITI.ttf（Mac 自带）</li>
<li>华文琥珀：STHUPO.TTF（Mac 自带）</li>
</ul>
</li>
<li>下载 <a href="http://liam0205.me/attachment/LaTeX-useful-tools/zhfzfonts.tex"><code>zhfzfonts.tex</code></a></li>
<li>将 <code>zhfzfonts.tex</code> 保存在 <code>TEXMFLOCAL/tex/generic/zhmetrics/</code> 目录下</li>
<li>使用 texhash 刷新文件名数据库（可能需要 root 权限）</li>
<li>调整代码</li>
</ol>
<p>这里 TEXMFLOCAL 指的是 TeX Live 供用户使用的 TDS 根目录，在 MacTeX 里是 <code>/usr/local/texlive/texmf-local</code>。</p>
<p><code>CJK</code> 支持 GBK，也支持 UTF-8。请注意将文档编码保存为与 <code>CJK</code> 环境相同的编码格式。</p>
<h2 id="CCT"><code>CCT</code></h2>
<p>以系统工程理论与实践为代表的一些国内期刊，使用 <code>CCT</code> 模板。前年为此写过一篇博客，专门讨论此类模板。参见：<a href="http://liam0205.me/2013/10/15/LaTeX-CCT-template/">国内期刊 CCT 模板编译经验</a></p>
<p><code>CCT</code> 只支持 GBK 编码。</p>
<h2 id="ctex_ 宏包 / 文档类 "><code>ctex</code> 宏包 / 文档类</h2>
<p><code>ctex</code> 宏包 / 文档类在使用 XeLaTeX 编译的时候，使用 <code>xeCJK</code> 作为中文支持方式；在使用 LaTeX/pdfLaTeX 的时候使用 <code>CJK</code> 作为中文支持方式。因此，使用 <code>ctex</code> 宏包 / 文档类的模板，在 TeX Live 系统下的配置方式需要根据所选的编译方式做调整。</p>
<p>使用 XeLaTeX 的时候，需要给 <code>ctex</code> 加上 <code>nofonts</code> 选项（将来的 2.0 版本则是 fontset = none），然后再用 <code>\setCJKmainfont</code> 配置字体。</p>
<p>使用 LaTeX/pdfLaTeX 的时候，则可以使用 <code>zhfzfonts.tex</code> 来映射字体。</p>
<p>使用 <code>ctex</code> 宏包 / 文档类的时候，需要根据所选的编译方式和宏包 / 文档类选项来确定源文件的编码格式。</p>
<ul>
<li>使用 XeLaTeX 的时候，不论选项为何，源文件都需要保存为 UTF-8 编码。</li>
<li>使用 LaTeX/pdfLaTeX 的时候，则需要根据宏包 / 文档类选项来确定源文件的编码格式。</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>中国人使用 LaTeX 的一大问题就是为文档添加中文支持。国内很多学校、期刊都有自己的模板，更多的是一些个人配置的勉强成型的小模板。Mac 用户安装 MacTeX 之后，可能会很头疼如何将这些模板移植到自己的电脑上。这篇文章对此做一个方法上的讨论。</p>
]]></summary>
    
      <category term="Template" scheme="http://liam0205.me/tags/Template/"/>
    
      <category term="Chinese" scheme="http://liam0205.me/tags/Chinese/"/>
    
      <category term="MacTeX" scheme="http://liam0205.me/tags/MacTeX/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 LaTeX 中将不编号的章节列入目录]]></title>
    <link href="http://liam0205.me/2015/04/10/how-to-list-unnumbered-section-in-the-table-of-contents/"/>
    <id>http://liam0205.me/2015/04/10/how-to-list-unnumbered-section-in-the-table-of-contents/</id>
    <published>2015-04-10T09:54:32.000Z</published>
    <updated>2015-04-10T10:41:32.000Z</updated>
    <content type="html"><![CDATA[<p>LaTeX 标准文档类提供了 <code>\section</code> 和 <code>\section*</code> 等两组命令，用于排版章节标题。其中不带星号的版本有章节编号，会列入目录，同时修改章节标记。带星号的版本只有章节标题格式而不编号，不列入目录，也不会修改章节标记。</p>
<p>有时，我们会希望将不编号的章节标题列入目录。这种情况使用 <code>\section</code> 或 <code>\section*</code> 都不大合适。本文将对这些问题做出分析，并给出解决方案。</p>
<a id="more"></a>

<p>LaTeX 标准文档类的 <code>\section</code> 命令做四件事情：</p>
<ol>
<li>编号自增 1</li>
<li>输出章节标题</li>
<li>处理目录（和 PDF 书签）</li>
<li>做页眉的章节标记</li>
</ol>
<p>相应地，<code>\section*</code> 命令只做上述第二件事情，其余三件都不做。</p>
<p>因此，我们的思路很简单，有两个方向。第一，使用 <code>\section*</code>，手工做目录的处理；第二，使用 <code>\section</code>，但是抑制编号。</p>
<h2 id=" 思路一 ">思路一</h2>
<p>LaTeX 处理目录需要编译两次。在第一次编译的过程中，<code>\section</code> 命令将目录信息写入 <code>.aux</code> 文件。随后，在第二次编译的过程中，LaTeX 读取 <code>.aux</code> 文件中的相应信息，形成目录。因此，我们只需要模仿 <code>\section</code> 写入 <code>.aux</code> 文件的过程就可以了。</p>
<p>LaTeX 提供了 <code>\addcontentsline{&lt; 辅助文件后缀 &gt;}{&lt; 章节等级 &gt;}{名字}</code> 命令来做这样的工作。我们来看一个例子。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>ctexart<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\tableofcontents</span>
<span class="command">\section*</span><span class="special">{</span>不编号的章节标题<span class="special">}</span>
<span class="command">\addcontentsline</span><span class="special">{</span>toc<span class="special">}</span><span class="special">{</span>section<span class="special">}</span><span class="special">{</span>不编号的章节标题<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<h2 id=" 思路二 ">思路二</h2>
<p>LaTeX 标准文档类中的 <code>\appendix</code> 命令，会使得后续的章节标题从 0 开始编号，同时将编号格式从阿拉伯数字修改为大写英文字母。<code>\appendix</code> 命令虽然不符合我们的需求，但是产生的效果却和我们需要的效果类似：修改了章节标题编号。我们可以对这个命令做适当的修改，达成我们的目的。</p>
<p>我们来看一下 <code>article.cls</code> 里的 <code>\appendix</code> 是如何定义的。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="command">\newcommand</span><span class="command">\appendix</span><span class="special">{</span><span class="command">\par</span>
  <span class="command">\setcounter</span><span class="special">{</span>section<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\setcounter</span><span class="special">{</span>subsection<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\gdef</span><span class="command">\thesection</span><span class="special">{</span><span class="command">\@</span>Alph<span class="command">\c</span>@section<span class="special">}</span><span class="special">}</span>
</pre></td></tr></table></figure>



<p>接下来，我们仿造它，定义一个新的命令 <code>\specialsectioning</code>。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">[</span>hyperref<span class="special">]</span><span class="special">{</span>ctexart<span class="special">}</span>
<span class="command">\newcommand</span><span class="command">\specialsectioning</span><span class="special">{</span><span class="command">\par</span>
  <span class="command">\setcounter</span><span class="special">{</span>section<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\setcounter</span><span class="special">{</span>subsection<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\renewcommand</span><span class="command">\thesection</span><span class="special">{</span><span class="command">\relax</span><span class="special">}</span><span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\tableofcontents</span>
<span class="command">\section</span><span class="special">{</span>正常编号的章节标题<span class="special">}</span>
<span class="command">\specialsectioning</span>
<span class="command">\section</span><span class="special">{</span>不编号的章节标题<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>编译之后我们会发现，在 <code>\specialsectioning</code> 之后的 <code>\section</code> 虽然不带星花，但已然不编号了，并且出现在了目录当中。</p>
<p>不过，正常标题的编号和标题正文之间是有一定的空距的。我们现在虽然将编号取消了，但是这个空距依然存在。虽然它不明显，但是毕竟是个问题。作为一个精益求精的完美主义者，我们要解决它。</p>
<p>正文中编号的格式由 LaTeX 内部宏 <code>\@seccntformat</code> 控制，默认是在编号后面加一个 <code>\quad</code>，我们把它去掉。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command">\def</span><span class="command">\@</span>seccntformat<span class="special">#</span><span class="special">#</span>1<span class="special">{</span><span class="command">\@</span>nameuse<span class="special">{</span>the<span class="special">#</span><span class="special">#</span>1<span class="special">}</span><span class="special">}</span>
</pre></td></tr></table></figure>



<p>此外，目录中的编号和章节标题之间也有距离，我们通过 <code>tocloft</code> 宏包来将这个距离设置为 <code>0pt</code>。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command">\addtocontents</span><span class="special">{</span>toc<span class="special">}</span><span class="special">{</span><span class="command">\def</span><span class="command">\cftsecnumwidth</span><span class="special">{</span>0pt<span class="special">}</span><span class="special">}</span>
</pre></td></tr></table></figure>



<p>这样，完整的代码变成：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>ctexart<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>tocloft<span class="special">}</span>
<span class="command">\makeatletter</span>
<span class="command">\newcommand</span><span class="command">\specialsectioning</span><span class="special">{</span><span class="command">\par</span>
  <span class="command">\setcounter</span><span class="special">{</span>section<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\setcounter</span><span class="special">{</span>subsection<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\renewcommand</span><span class="command">\thesection</span><span class="special">{</span><span class="command">\relax</span><span class="special">}</span><span class="comment">%</span>
  <span class="command">\def</span><span class="command">\@</span>seccntformat<span class="special">#</span><span class="special">#</span>1<span class="special">{</span><span class="command">\@</span>nameuse<span class="special">{</span>the<span class="special">#</span><span class="special">#</span>1<span class="special">}</span><span class="special">}</span><span class="comment">%</span>
  <span class="command">\addtocontents</span><span class="special">{</span>toc<span class="special">}</span><span class="special">{</span><span class="command">\def</span><span class="command">\cftsecnumwidth</span><span class="special">{</span>0pt<span class="special">}</span><span class="special">}</span><span class="special">}</span>
<span class="command">\makeatother</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\tableofcontents</span>
<span class="command">\section</span><span class="special">{</span>正常编号的章节标题<span class="special">}</span>
<span class="command">\specialsectioning</span>
<span class="command">\section</span><span class="special">{</span>不编号的章节标题<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<hr>
<p>问题解决了，不过思路二这样做未免麻烦。在这个思路下，会不会有更简单的方法呢？答案是肯定的。</p>
<p>在 LaTeX 标准文档类中，secnumdepth 这个计数器是用来控制章节编号深度的。在 article 中，这个计数器的值默认是 3，对应的章节命令是 \subsubsection。也就是说，默认情况下，article 将会对 \subsubsection 及其之上的所有章节标题进行编号，也就是 \part, \section, \subsection, \subsubsection。</p>
<p>LaTeX 标准文档类中，最大的标题是 \part。它在 book 和 report 类中的层级是「-1」，在 article 类中的层级是「0」。因此，我们只需要将计数器设置为 -2，之后章节命令都不会编号了，从而解决问题。</p>
<p>我们来看一下代码。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>ctexart<span class="special">}</span>
<span class="command">\makeatletter</span>
<span class="command">\newcommand</span><span class="command">\specialsectioning</span><span class="special">{</span><span class="command">\setcounter</span><span class="special">{</span>secnumdepth<span class="special">}</span><span class="special">{</span>-2<span class="special">}</span><span class="special">}</span>
<span class="command">\makeatother</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\tableofcontents</span>
<span class="command">\section</span><span class="special">{</span>正常编号的章节标题<span class="special">}</span>
<span class="command">\specialsectioning</span>
<span class="command">\section</span><span class="special">{</span>不编号的章节标题<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>怎么样？是不是简单多了？</p>
]]></content>
    <summary type="html"><![CDATA[<p>LaTeX 标准文档类提供了 <code>\section</code> 和 <code>\section*</code> 等两组命令，用于排版章节标题。其中不带星号的版本有章节编号，会列入目录，同时修改章节标记。带星号的版本只有章节标题格式而不编号，不列入目录，也不会修改章节标记。</p>
<p>有时，我们会希望将不编号的章节标题列入目录。这种情况使用 <code>\section</code> 或 <code>\section*</code> 都不大合适。本文将对这些问题做出分析，并给出解决方案。</p>
]]></summary>
    
      <category term="Section" scheme="http://liam0205.me/tags/Section/"/>
    
      <category term="Sectioning" scheme="http://liam0205.me/tags/Sectioning/"/>
    
      <category term="Numbering" scheme="http://liam0205.me/tags/Numbering/"/>
    
      <category term="Table of Contents" scheme="http://liam0205.me/tags/Table%20of%20Contents/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[将微信上的文章推送到 Kindle 上]]></title>
    <link href="http://liam0205.me/2015/03/23/push-articles-to-kindle-from-wechat/"/>
    <id>http://liam0205.me/2015/03/23/push-articles-to-kindle-from-wechat/</id>
    <published>2015-03-23T03:23:24.000Z</published>
    <updated>2015-03-23T04:57:11.000Z</updated>
    <content type="html"><![CDATA[<p>微信是近几年发展起来的社交网络。微信公众号和微信朋友圈的出现，让微信变成了一个优秀的信息发布和传播平台。有甄别能力的同好，往往能在微信上找到不少好的文章。但是，一来用手机查看文章伤眼，二来微信上的文章不变保存，三来用手机看文章需要网络支持。总之，是有诸多不便。</p>
<p>昨天思考到这个问题之后，我有做一些搜索，而后就有了欣喜的发现：可以将微信里的文章、好友发来的文字消息免费推送到 Kindle 设备上。</p>
<a id="more"></a>

<h2 id=" 原理 ">原理</h2>
<p>激活 Kindle 之后，亚马逊都会为每一台 Kindle 设备分配一个电邮地址。向这个电邮地址里发送包含电子书的邮件，就可以将电子书推送到 Kindle 上了。当然，如此的话，可能会造成垃圾信息泛滥。因为如果不加限制，任何人都能往用户的 Kindle 上推送文件，结果会是一团糟。基于这些考虑，在亚马逊官网的后台里，提供了「认可的电邮地址」的设置。亚马逊在收到邮件之后，会检查这个认可的电邮列表。只有来信电邮在列表当中，亚马逊才会将电子书推送到 Kindle 上。</p>
<p>简单来说，亚马逊将 Kindle 和一个特定的电邮地址关联在一起，通过可信邮箱往上述电邮地址发送邮件，就能把附件中的电子书推送到 Kindle 上。</p>
<p>有了这样的基础知识，就不难理解微信推送的原理了。</p>
<p>亚马逊官方在微信上设立了一个公众平台，平台的后端就是一个电子邮箱。我们将微信上的文章保存在公众平台里，后端邮箱就会把文章发送到 Kindle 邮箱中，最后再推送到 Kindle 设备上。</p>
<p><img src="/attachment/images/Kindle/wechat_flowchat.png" alt=" 推送流程图 "></p>
<p>明确原理之后，我们来进行设置。</p>
<h2 id=" 亚马逊官网 ">亚马逊官网</h2>
<p>这里以中国亚马逊为例，如果你的 Kindle 使用的是美国亚马逊账号，请登录美国亚马逊网站进行相应操作。</p>
<p>登录中亚之后，点击下面的链接，进入 Kindle 管理页面。</p>
<p><a href="https://www.amazon.cn/mn/dcw/myx.html" target="_blank">https://www.amazon.cn/mn/dcw/myx.html</a></p>
<p>进入「我的设备」一栏，找到你的 Kindle 设备对应的图标。页面下方会显示出该设备对应的 Kindle 邮箱，请记下来。</p>
<p><img src="/attachment/images/Kindle/amazon01.png" alt=" 记录 Kindle 邮箱地址 "></p>
<p>进入「设置」一栏，在页面底部，点击「添加认可的电子邮箱」，将 <code>kindle@eub-inc.com</code> 添加到列表当中。</p>
<p><img src="/attachment/images/Kindle/amazon02.png" alt=" 将 `kindle@eub-inc.com` 添加到认可的电子邮箱列表当中 "></p>
<h2 id=" 微信 ">微信</h2>
<p>首先我们要关注亚马逊的微信公众平台。搜索公众号 <code>cn_Kindle</code> 并关注「亚马逊 Kindle 服务号」。</p>
<p><img src="/attachment/images/Kindle/wechat01.jpg" alt=" 亚马逊 Kindle 服务号 "></p>
<p>接下来，进入服务号界面，向服务号发送消息 <code>绑定 + 你的 Kindle 邮箱地址</code>。比如 <code>绑定 +myemail@kindle.cn</code>。</p>
<p><img src="/attachment/images/Kindle/wechat02.jpg" alt=" 绑定 Kindle 邮箱地址 "></p>
<h2 id=" 实际使用看看 ">实际使用看看</h2>
<p>周筠老师今天分享了一篇文章，我们把它推送到 Kindle 上看看。</p>
<p>打开这篇文章后，点击右上角的 <code>···</code>，选择「亚马逊 Kindle 服务号」。</p>
<p><img src="/attachment/images/Kindle/wechat03.jpg" alt=" 一键推送到 Kindle"></p>
<p>将你的 Kindle 设备连上网络，过一会儿，就能收到推送了。</p>
<p><img src="/attachment/images/Kindle/kindle01.png" alt="Kindle 截图 "></p>
]]></content>
    <summary type="html"><![CDATA[<p>微信是近几年发展起来的社交网络。微信公众号和微信朋友圈的出现，让微信变成了一个优秀的信息发布和传播平台。有甄别能力的同好，往往能在微信上找到不少好的文章。但是，一来用手机查看文章伤眼，二来微信上的文章不变保存，三来用手机看文章需要网络支持。总之，是有诸多不便。</p>
<p>昨天思考到这个问题之后，我有做一些搜索，而后就有了欣喜的发现：可以将微信里的文章、好友发来的文字消息免费推送到 Kindle 设备上。</p>
]]></summary>
    
      <category term="WeChat" scheme="http://liam0205.me/tags/WeChat/"/>
    
      <category term="Kindle" scheme="http://liam0205.me/tags/Kindle/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么我乐于分享？]]></title>
    <link href="http://liam0205.me/2015/03/19/why-i-love-to-share/"/>
    <id>http://liam0205.me/2015/03/19/why-i-love-to-share/</id>
    <published>2015-03-19T11:39:39.000Z</published>
    <updated>2015-03-19T12:39:15.000Z</updated>
    <content type="html"><![CDATA[<p>今天在<a href="http://www.zhihu.com" target="_blank">知乎</a>上第一次尝试回答了<a href="http://www.zhihu.com/question/25520742/answer/42443974" target="_blank">一个感情类问题</a>，得到了<a href="http://www.zhihu.com/people/yeka" target="_blank">周筠老师</a>的赞同。虽说是感情类问题，但主要想提及的是关于分享和共同进步的问题。无奈这个话题相对提问来说有些偏，所以只能另开文章讨论。</p>
<a id="more"></a>

<p>媳妇儿是个文科生，偏偏和我这个理科生看对了眼。我喜欢文学，却不得要领。每次看见媳妇儿写的文章，都羡慕嫉妒并着抓耳挠腮。媳妇儿是典型的文科生，对现象和规律不如理科生那么敏感。正赶着媳妇儿要学开车，对离合器一无所知有些犯怵。走在张家界的澧水大桥上，我就给她从她接触过的几个简单的物理公式讲起，借着变速自行车的例子把离合器和变速箱的原理讲了一遍。我不知道媳妇儿有没有都听明白，但是我讲完扭头看着她，分明是一脸崇拜的花痴样（我已经做好了跪搓衣板的准备，笑）。</p>
<p>媳妇儿说，她前男友是学语言的。偏偏媳妇儿是一个上进的姑娘，那时见着男朋友懂这门语言，就想请教。然而他却怎么也不肯教，问起原因，说是「担心教会了之后就没有吸引力了」。于是媳妇儿就问我，为什么我愿意将我所知道的知识分享给她。我说，「我把这些东西教给你，帮你打开思路，那样每天就能看见一个更好的你了，而且我也有向你学习啊」。</p>
<p>其实，两个人学习的专业不同、从事的行业不同、经历的人生不同，这些不同必然造成思维方式和处事模式的差异。两个人互相从对方身上学习，互相进步，这样日子才会过得越来越好，关系也会越来越亲密。</p>
<p>后来回到住处，媳妇儿给我说「你知道嘛，爱情就是两个人互相促进共同进步，所以我和你在一起特别有安全感」。文科生就是文科生，不对，媳妇儿不愧是我媳妇儿，我对媳妇儿这句话深表赞同，而且我认为在工作上也是如此。</p>
<p>父亲在我小的时候，因为工作的关系，去过不少公司工厂。每次出差回来，父亲都会讲讲所见所闻。虽然大多数的故事我都记不得了，但是有一则故事我一直记到现在。</p>
<p>父亲说，那次去的化工厂的技术部副主任以前是个技术过硬的老师傅，靠着自己的技术一步步走到这个位置。但是，现在的主任比他年轻得多，而且是以前还在他手下干过活。其实按照老师傅的资历和技术，他早就可以得到提拔。只是老师傅当年掌握着关键技术，因为害怕被人取代，所以不真心实意地教徒弟。这样一来，很长时间里都没有人能代替老师傅的位置。因此虽然薪资加了不少，但是领导一直不怎么提拔他。他就只能看着自己曾经的手下一步步超越自己。</p>
<p>其实，一方面，总结和分享的过程对自己也是一种学习；另一方面，学习是相互的，在自己分享的过程中，也会从对方身上学到自己不具备的东西；再者，给对方机会也最终是给自己机会。所以，真正自信的人都不会害怕分享自己的知识和技能，他们的着眼点永远是共同进步，一起变得更好。</p>
<p>所以啊，在被请教的时候，以及，更多地在生活的细微末节上，都不要吝惜自己的知识不乐于分享，更不要自觉高人一等盛气凌人。我一直认为，成长不是变得势利，而是变得温柔，对全世界都温柔。乐于分享，乐于共同进步，就是一种温柔呢。</p>
]]></content>
    <summary type="html"><![CDATA[<p>今天在<a href="http://www.zhihu.com" target="_blank">知乎</a>上第一次尝试回答了<a href="http://www.zhihu.com/question/25520742/answer/42443974" target="_blank">一个感情类问题</a>，得到了<a href="http://www.zhihu.com/people/yeka" target="_blank">周筠老师</a>的赞同。虽说是感情类问题，但主要想提及的是关于分享和共同进步的问题。无奈这个话题相对提问来说有些偏，所以只能另开文章讨论。</p>
]]></summary>
    
      <category term="Share" scheme="http://liam0205.me/tags/Share/"/>
    
      <category term="Life" scheme="http://liam0205.me/categories/Life/"/>
    
  </entry>
  
</feed>
