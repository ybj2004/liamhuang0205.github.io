<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[始终]]></title>
  <subtitle><![CDATA[不忘初心]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liam0205.me/"/>
  <updated>2015-05-23T01:13:00.184Z</updated>
  <id>http://liam0205.me/</id>
  
  <author>
    <name><![CDATA[Liam Huang]]></name>
    <email><![CDATA[liamhuang0205+blog@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[CTeX 2.0 发布 · 新功能简介]]></title>
    <link href="http://liam0205.me/2015/05/16/ctex-20-released/"/>
    <id>http://liam0205.me/2015/05/16/ctex-20-released/</id>
    <published>2015-05-16T15:04:52.000Z</published>
    <updated>2015-05-16T15:10:21.000Z</updated>
    <content type="html"><![CDATA[<p>CTeX 2.0 的代码主要是 李清 用 LaTeX 3 的语法书写的。之后 刘海洋 对代码做了一些调整，并构建了第一个版本的套件手册。再之后，在测试版本发布之后，我重构了套件手册，成为你们现在看到的这个样子。</p>
<p>现在，新版套件已经上传，CTAN 地址是：<a href="http://www.ctan.org/pkg/ctex" target="_blank">http://www.ctan.org/pkg/ctex</a></p>
<a id="more"></a>

<p>首先说一下关于 CTeX 这个名字。<br>CTeX 的 C 是 China 或者 Chinese 的意思，在纯文本环境下，应该写作 CTeX。<br>CTeX 套件是由 CTeX 社区 发起并维护的 LaTeX 宏包和文档类集合。社区另有发布名为 CTeX 套装 的 TeX 发行版。<br>ctex 是本套件中 <code>ctex.sty</code> 的名字。这一小写的名字过去被用来代指整个 CTeX 套件，不过现在则专指 <code>ctex.sty</code> 这一宏包。不过，在一些特殊的情况下，由于历史原因，为了与 CTeX 套装做区分，也会用 ctex 来代指整个 CTeX 套件。</p>
<p>本次更新的是 CTeX 套件，版本号从 1.02d 升级到 2.0 （当前修复了一些问题，版本号是 2.0.2）。CTeX 套装的最新版本是 2.9.2.164，已有若干年未更新，将来可能也不会再更新，也不推荐使用。</p>
<p>CTeX 2.0 里比较重大的改变有四个：</p>
<ul>
<li>对底层引擎的支持，放弃了 CCT，新增了 LuaLaTeX（基于 <code>LuaTeX-ja</code>）；</li>
<li>增强了字库选择，新增了华文、Fandol、方正等字库，并提供了基于操作系统自动选择字库的功能；</li>
<li>增强了 <code>ctex.sty</code> 的功能，用键值列表的方式提供选项支持，并提供全新的 \ctexset 接口；</li>
<li>关于字号的部分，在 <code>ctexsize.sty</code> 中单独列出，可独立于 CTeX 宏包或文档类使用。</li>
</ul>
<p>除此之外，特别有意义的一点是，新版套件可以做到「只提供中文支持，不改变版式风格」。只需要这样：</p>
<pre><code><span class="attribute">\usepackage[scheme </span>=<span class="string"> plain]{ctex}</span>
</code></pre><p>特别适用于在英文文档中需要添加少许汉字的情况。</p>
<p>除此之外，用户可能会比较关心新版套件对旧版宏包的兼容性问题。CTeX 2.0 对使用时间较长的稳定版本 1.02c 和 1.02d 做了尽可能的兼容。基于这两个旧版本的宏包书写的文档，在新版本下可以不作任何修改地编译，并且效果几乎一致，但有一些过时选项需要注意。这些选项在新版套件中基于兼容性考虑被保留，但在将来可能被移除。完整的兼容性可参看套件手册 12.2 节，这里列出部分比较重要的：</p>
<ul>
<li><code>cs4size</code> 和 <code>c5size</code>：旧版宏包用于选择文档全局字号的选项，已过时，相当于新版套件 <code>zihao = -4</code> 和 <code>zihao = 5</code> 的功能。</li>
<li><code>cap</code> 和 <code>nocap</code>：旧版宏包用于选择排版风格的选项，已过时，相当于新版套件 <code>scheme = chinese</code> 和 <code>scheme = plain</code> 的功能。</li>
<li><code>fancyhdr</code>, <code>hyperref</code> 和 <code>fntef</code>：旧版宏包的兼容性选项，均已过时。新版套件默认打开兼容性，不过需要用户手工载入相关宏包（<code>fancyhdr</code> 和 <code>hyperref</code>）。出于兼容性考虑，选项保留，功能是载入相关宏包。</li>
<li><code>ctexcap.sty</code>：过时宏包，相当于 <code>\usepackage[heading = true]{ctex}</code>，不推荐使用。</li>
</ul>
<p>具体的内容，烦请参看新版套件手册。关于 <code>\ctexset</code>，有不少「很犀利」的用法哦~</p>
]]></content>
    <summary type="html"><![CDATA[<p>CTeX 2.0 的代码主要是 李清 用 LaTeX 3 的语法书写的。之后 刘海洋 对代码做了一些调整，并构建了第一个版本的套件手册。再之后，在测试版本发布之后，我重构了套件手册，成为你们现在看到的这个样子。</p>
<p>现在，新版套件已经上传，CTAN 地址是：<a href="http://www.ctan.org/pkg/ctex" target="_blank">http://www.ctan.org/pkg/ctex</a></p>
]]></summary>
    
      <category term="CTeX" scheme="http://liam0205.me/tags/CTeX/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hyperref 宏包 psdextra 选项的 bug 及其 quick fix]]></title>
    <link href="http://liam0205.me/2015/05/11/bug-of-the-hyperref-package-with-mu-in-section-heading/"/>
    <id>http://liam0205.me/2015/05/11/bug-of-the-hyperref-package-with-mu-in-section-heading/</id>
    <published>2015-05-11T15:04:10.000Z</published>
    <updated>2015-05-11T15:17:41.000Z</updated>
    <content type="html"><![CDATA[<p>今天有人问到下列代码报错：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>article<span class="special">}</span>
<span class="comment">%\listfiles</span>
<span class="command">\usepackage</span><span class="special">[</span>unicode,psdextra<span class="special">]</span><span class="special">{</span>hyperref<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>unicode-math<span class="special">}</span>
<span class="command">\setmathfont</span><span class="special">{</span>Asana Math<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\section</span><span class="special">{</span><span class="formula">$<span class="command">\mu</span>$</span><span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>提示：</p>
<pre><code>Improper alphabetic <span class="built_in">constant</span>
</code></pre><p>看了一下，是 <code>hyperref</code> 宏包的 bug。</p>
<a id="more"></a>

<p>实际上，在处理 PDF 书签的时候，很多数学命令要被定义成相应的文本模式，比如 \geq 要被定义为 \textgeq。这个工作在 NFSS 里完成。</p>
<p>但是，数学符号那么多，总有 NFSS 定义不全的时候。于是 hyperref 提供了 psdextra 选项。该选项会载入 psdextra.def 这个文件，提供更多的定义。</p>
<p>不过 \mu 在 NFSS 里和 psdextra.def 里都处理错了。psdextra 里是处理了 \mugreek，而实际上应该是 \mu。于是就出问题了。</p>
<p>解决方法也很简单，自己处理一下就好了。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>article<span class="special">}</span>
<span class="comment">%\listfiles</span>
<span class="command">\usepackage</span><span class="special">[</span>unicode, psdextra<span class="special">]</span><span class="special">{</span>hyperref<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>unicode-math<span class="special">}</span>
<span class="command">\setmathfont</span><span class="special">{</span>Asana-Math.otf<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>etoolbox<span class="special">}</span>
<span class="command">\appto</span><span class="special">{</span><span class="command">\psdmapshortnames</span><span class="special">}</span><span class="special">{</span><span class="command">\let</span><span class="command">\mu</span><span class="command">\textmugreek</span><span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\section</span><span class="special">{</span><span class="formula">$<span class="command">\mu</span>$</span><span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>这里 <code>\appto</code> 命令接受两个参数，<code>\appto{&lt; 需要修补的命令 &gt;}{&lt; 填在命令最后的内容 &gt;}</code>。这里我们将 <code>\let\mu\textmugreek</code> 添加在命令 <code>\psdmapshortnames</code> 的最后，这样在处理 PDF 书签的时候，<code>\mu</code> 就能被正确处理了。</p>
<p>该 bug 已提交给 <code>hyperref</code> 宏包的作者。</p>
]]></content>
    <summary type="html"><![CDATA[<p>今天有人问到下列代码报错：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>article<span class="special">}</span>
<span class="comment">%\listfiles</span>
<span class="command">\usepackage</span><span class="special">[</span>unicode,psdextra<span class="special">]</span><span class="special">{</span>hyperref<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>unicode-math<span class="special">}</span>
<span class="command">\setmathfont</span><span class="special">{</span>Asana Math<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\section</span><span class="special">{</span><span class="formula">$<span class="command">\mu</span>$</span><span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>提示：</p>
<pre><code>Improper alphabetic <span class="built_in">constant</span>
</code></pre><p>看了一下，是 <code>hyperref</code> 宏包的 bug。</p>
]]></summary>
    
      <category term="Bug" scheme="http://liam0205.me/tags/Bug/"/>
    
      <category term="Hyperref" scheme="http://liam0205.me/tags/Hyperref/"/>
    
      <category term="Psdextra" scheme="http://liam0205.me/tags/Psdextra/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用 Python 生成随机的邀请码]]></title>
    <link href="http://liam0205.me/2015/05/07/generator-of-invitation-code-in-python/"/>
    <id>http://liam0205.me/2015/05/07/generator-of-invitation-code-in-python/</id>
    <published>2015-05-07T13:34:23.000Z</published>
    <updated>2015-05-07T13:34:14.000Z</updated>
    <content type="html"><![CDATA[<p>在很多场合，我们都需要生成一系列固定长度的字符串，分发给用户，作为邀请码或者兑换码。</p>
<p>关于邀请码，最容易想到的特征有二：一是足够长，二是不具有规律性。这两个特征主要是为了防止用户伪造邀请码，简单来说，就是让用户「猜对」正确邀请码的可能性足够小。不过，作为邀请码来说，仅有这两个特征还不够。</p>
<p>邀请码并不是发放给用户就结束了，还涉及到验证的过程。用户在收到邀请码之后，将邀请码提交给系统。系统在收到提交之后，要在数据库里查询是否有匹配的记录。所以生成邀请码时除了要防止用户伪造，还要方便后期的校验。这就要求我们能够从邀请码中，经过简单的变换，提取出「主键」。</p>
<p>这篇文章我们讨论一下如何用 Python 生成随机的邀请码。</p>
<a id="more"></a>

<h2 id=" 产生随机数 ">产生随机数</h2>
<p>Python 有自带的随机库，其名为 <code>random</code>。<code>random</code> 库中的 <code>randint(inf, sup)</code> 函数可以在指定的范围内产生一个随机整数；<code>choice(sequence)</code> 可以在一个有序的类型中（比如 <code>list</code>、<code>tuple</code> 或 <code>string</code>）随机选取一个元素。</p>
<p>这里我们需要产生一个 15 位的随机串，可以包含数字和大小写字母。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment"># import random, string</span>

poolOfChars  = string.ascii_letters + string.digits
random_codes = <span class="keyword">lambda</span> x, y: <span class="string">''</span>.join([random.choice(x) <span class="keyword">for</span> i <span class="keyword">in</span> range(y)])

<span class="keyword">print</span> random_codes(poolOfChars, <span class="number">15</span>)
</pre></td></tr></table></figure>



<h2 id=" 填充空位 ">填充空位</h2>
<p>为了方便统计，主键通常是一个递增的整数序列。如果主键的值从 1 增加到 1000，那么主键的「（十进制）位数」就会从 1 增加到 4。对于邀请码来说，我们需要固定其总长度。反应到主键上，我们就需要固定主键的长度。最简单的办法，就是用 0 填充（pad）空位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">LengthError</span><span class="params">(ValueError)</span>:</span>
   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span>
      self.args = arg

<span class="function"><span class="keyword">def</span> <span class="title">pad_zero_to_left</span><span class="params">(inputNumString, totalLength)</span>:</span>
    <span class="string">'''
    takes inputNumString as input,
    pads zero to its left, and make it has the length totalLength
    1. calculates the length of inputNumString
    2. compares the length and totalLength
        2.1 if length &gt; totalLength, raise an error
        2.2 if length == totalLength, return directly
        2.3 if length &lt; totalLength, pads zeros to its left
    '''</span>
    lengthOfInput = len(inputNumString)
    <span class="keyword">if</span> lengthOfInput &gt; totalLength:
        <span class="keyword">raise</span> LengthError(<span class="string">"The length of input is greater than the total\ length."</span>)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> <span class="string">'0'</span> * (totalLength - lengthOfInput) + inputNumString
</pre></td></tr></table></figure>



<h2 id=" 拼接 ">拼接</h2>
<p>至此，我们已经得到了主键和随机序列产生的方法，剩下的问题就是要拼接起来。拼接两个字符串很容易，但是我们在拼接完成之后，还要保证能够很容易地找到主键的部分。</p>
<p>为了达成这个目的，我们只需要在主键和随机串之间加上一个固定的字母，比如 <code>L</code>，作为标识符。</p>
<pre><code>bGH49U63p5zy3ULL0123
</code></pre><p>这样我们就知道，整个邀请码子串最后一个 <code>L</code> 之后，就是主键部分。我们有代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">invitation_code_generator</span><span class="params">(quantity, lengthOfRandom, LengthOfKey)</span>:</span>
    <span class="string">'''
    generate `quantity` invitation codes
    '''</span>
    placeHoldChar = <span class="string">"L"</span>
    <span class="keyword">for</span> index <span class="keyword">in</span> range(quantity):
        tempString = <span class="string">""</span>
        <span class="keyword">try</span>:
            <span class="keyword">yield</span> random_codes(poolOfChars, lengthOfRandom) + placeHoldChar + \
                pad_zero_to_left(str(index), LengthOfKey)
        <span class="keyword">except</span> LengthError:
            <span class="keyword">print</span> <span class="string">"Index exceeds the length of master key."</span>

<span class="keyword">for</span> invitationCode <span class="keyword">in</span> invitation_code_generator(<span class="number">200</span>, <span class="number">15</span>, <span class="number">4</span>):
    <span class="keyword">print</span> invitationCode
</pre></td></tr></table></figure>



<p>这样，我们就生成了 200 个邀请码。其中随机串长度为 15，主键长度为 4，分隔符为字母 <code>L</code>。</p>
]]></content>
    <summary type="html"><![CDATA[<p>在很多场合，我们都需要生成一系列固定长度的字符串，分发给用户，作为邀请码或者兑换码。</p>
<p>关于邀请码，最容易想到的特征有二：一是足够长，二是不具有规律性。这两个特征主要是为了防止用户伪造邀请码，简单来说，就是让用户「猜对」正确邀请码的可能性足够小。不过，作为邀请码来说，仅有这两个特征还不够。</p>
<p>邀请码并不是发放给用户就结束了，还涉及到验证的过程。用户在收到邀请码之后，将邀请码提交给系统。系统在收到提交之后，要在数据库里查询是否有匹配的记录。所以生成邀请码时除了要防止用户伪造，还要方便后期的校验。这就要求我们能够从邀请码中，经过简单的变换，提取出「主键」。</p>
<p>这篇文章我们讨论一下如何用 Python 生成随机的邀请码。</p>
]]></summary>
    
      <category term="Python" scheme="http://liam0205.me/tags/Python/"/>
    
      <category term="Invitation Code" scheme="http://liam0205.me/tags/Invitation%20Code/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让所有的公式都使用正文直立字体]]></title>
    <link href="http://liam0205.me/2015/05/07/make-every-equations-in-your-document-upright/"/>
    <id>http://liam0205.me/2015/05/07/make-every-equations-in-your-document-upright/</id>
    <published>2015-05-07T09:33:54.000Z</published>
    <updated>2015-05-07T09:53:34.000Z</updated>
    <content type="html"><![CDATA[<p>首先说明，<strong>这是邪道</strong>，除非你知道自己在干什么，请不要使用这篇文章提到的方法。这篇文章纯粹是一个技巧的记录，在某些时候可能会有用。</p>
<p>有时候我们会需要将公式字体修改为正文的 <code>\rmfamily\upright\normalsize</code> 的样式。虽然看起来很复杂，其实却很简单。我们只需要在导言区末尾添加以下两行代码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="command">\everymath</span><span class="command">\expandafter</span><span class="special">{</span><span class="command">\the</span><span class="command">\everymath</span><span class="command">\mathgroup</span>0<span class="special">}</span>
<span class="command">\everydisplay</span><span class="command">\expandafter</span><span class="special">{</span><span class="command">\the</span><span class="command">\everydisplay</span><span class="command">\mathgroup</span>0<span class="special">}</span>
</pre></td></tr></table></figure>



<a id="more"></a>

<h3 id=" 解释 ">解释</h3>
<p>这里实际起作用的是 <code>\mathgroup0</code>。它将数学字体设置为第 <code>0</code> 组字体，也就是正文字体。</p>
<p>而 <code>\expandafter{\the\everymath</code> 能在外层的 <code>\everymath</code> 起作用之前，先将内层的 <code>\everymath</code> 展开。这样可以将 <code>\everymath</code> 的结果保留。若不然，比如有代码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="command">\everymath</span><span class="special">{</span><span class="command">\displaystyle</span><span class="special">}</span>
<span class="command">\everymath</span><span class="special">{</span><span class="command">\mathgroup</span>0<span class="special">}</span>
</pre></td></tr></table></figure>



<p>作者的本意是将每个行内数学公式都是用 <code>\displaystyle</code>，同时设置字体为正文字体。但实际上，由于第二行的存在，第一行的效果被覆盖掉了。为了保证我们添加的代码不影响已有的设置，所以要用 <code>\expandafter{\the\everymath</code> 的方式对已有的设置进行保护。例如，下面的代码则可以达到目的：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="command">\everymath</span><span class="special">{</span><span class="command">\displaystyle</span><span class="special">}</span>
<span class="command">\everymath</span><span class="command">\expandafter</span><span class="special">{</span><span class="command">\the</span><span class="command">\everymath</span><span class="command">\mathgroup</span>0<span class="special">}</span>
</pre></td></tr></table></figure>



]]></content>
    <summary type="html"><![CDATA[<p>首先说明，<strong>这是邪道</strong>，除非你知道自己在干什么，请不要使用这篇文章提到的方法。这篇文章纯粹是一个技巧的记录，在某些时候可能会有用。</p>
<p>有时候我们会需要将公式字体修改为正文的 <code>\rmfamily\upright\normalsize</code> 的样式。虽然看起来很复杂，其实却很简单。我们只需要在导言区末尾添加以下两行代码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="command">\everymath</span><span class="command">\expandafter</span><span class="special">{</span><span class="command">\the</span><span class="command">\everymath</span><span class="command">\mathgroup</span>0<span class="special">}</span>
<span class="command">\everydisplay</span><span class="command">\expandafter</span><span class="special">{</span><span class="command">\the</span><span class="command">\everydisplay</span><span class="command">\mathgroup</span>0<span class="special">}</span>
</pre></td></tr></table></figure>



]]></summary>
    
      <category term="Equation" scheme="http://liam0205.me/tags/Equation/"/>
    
      <category term="Font" scheme="http://liam0205.me/tags/Font/"/>
    
      <category term="Upright" scheme="http://liam0205.me/tags/Upright/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PIL 简明教程 - 在现有的图片上涂涂改改]]></title>
    <link href="http://liam0205.me/2015/05/05/pil-tutorial-imagedraw-and-imagefont/"/>
    <id>http://liam0205.me/2015/05/05/pil-tutorial-imagedraw-and-imagefont/</id>
    <published>2015-05-04T16:15:06.000Z</published>
    <updated>2015-05-05T13:32:55.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://liam0205.me/2015/04/22/pil-tutorial-basic-usage/">上一篇文章</a> 介绍了 PIL 的基本情况，以及 <code>Image</code> 模块的基本用法。这篇文章，我们讨论一下 <code>ImageDraw</code> 和 <code>ImageFont</code> 两个模块的基本用法，说说如何用 PIL 在现有的图片上涂涂改改。</p>
<a id="more"></a>

<h2 id="ImageDraw_ 模块 "><code>ImageDraw</code> 模块</h2>
<p><code>ImageDraw</code> 模块提供了 <code>Draw</code> 类，它能在 <code>Image</code> 实例上进行简单的 2D 绘图。当然复杂的绘图动作是由简单的动作合成而得的，理论上这些动作 <code>ImageDraw</code> 模块也能做，只是相对复杂。如果你想在 <code>Image</code> 实例上做复杂的绘图动作，最好是自行对 <code>ImageDraw</code> 模块提供的各种方法做一些封装。</p>
<h3 id=" 创建一个 _Draw_ 类的实例 ">创建一个 <code>Draw</code> 类的实例</h3>
<p>要在 <code>Image</code> 实例上绘制新的图样，首先要做的就是创建一个 <code>Draw</code> 类的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">import</span> Image, ImageDraw
sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
drawAvatar     = ImageDraw.Draw(avatar)
</pre></td></tr></table></figure>



<p>代码前三行我们已经见过，唯一的差别在于 <code>import</code> 之后除了我们已经见过的 <code>Image</code> 模块，还有今次我们要使用的 <code>ImageDraw</code> 模块。</p>
<h3 id=" 从画两条平行线开始 ">从画两条平行线开始</h3>
<p><code>Draw</code> 类提供了 <code>line(xy, options)</code> 方法绘制直线。</p>
<p>其中 <code>xy</code> 表示坐标列表，其形式可以是</p>
<ul>
<li><code>[(x1, y1), (x2, y2), ...]</code> - 包含若干个元组的列表</li>
<li><code>[x1, y1, x2, y2, ...]</code> - 按照顺序包含坐标信息的列表</li>
<li><code>[x1, y1, (x2, y2), ...]</code> - 以上两种情况的混合</li>
<li><code>((x1, y1), (x2, y2), ...)</code> - 包含若干个元组的元组</li>
<li><code>(x1, y1, x2, y2, ...)</code> - 按照顺序包含坐标信息的元组</li>
<li><code>(x1, y1, (x2, y2), ...)</code> - 以上两种情况的混合</li>
</ul>
<p><code>options</code> 中可用的选项有</p>
<ul>
<li><code>fill = (R, G, B)</code> - 用于指定线条的颜色，其中 <code>R</code>、<code>G</code>、<code>B</code> 都是 0 — 255 的整数</li>
<li><code>width = integer</code> - 用于指定线条的宽度，单位是像素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">import</span> Image, ImageDraw
sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
drawAvatar     = ImageDraw.Draw(avatar)

xSize, ySize = avatar.size

drawAvatar.line([<span class="number">0</span>, <span class="number">0.33</span> * ySize, xSize, <span class="number">0.33</span> * ySize],\
    fill = (<span class="number">255</span>, <span class="number">100</span>, <span class="number">0</span>), width = <span class="number">3</span>)
drawAvatar.line([<span class="number">0</span>, <span class="number">0.67</span> * ySize, xSize, <span class="number">0.67</span> * ySize],\
    fill = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), width = <span class="number">3</span>)
<span class="keyword">del</span> drawAvatar

avatar.show()
</pre></td></tr></table></figure>



<p>这里我们在图片的两个三等分位置分别画了一条宽度为 3 像素的平行线。一条颜色为 (255, 100, 0)，另一条则是 (255, 0, 0)。</p>
<p>值得注意的是代码的第 14 行，我们直接用 <code>avatar.show()</code> 来展现绘图的结果。可见<strong><code>Draw</code> 类的实例将直接在 <code>Image</code> 实例上进行操作</strong>。</p>
<p><img src="/attachment/images/Python/pil-tutorial/draw-line.png" alt="line 方法效果示例 "></p>
<h3 id=" 画一段弧 ">画一段弧</h3>
<p><code>Draw</code> 类也提供了 <code>arc(xy, start, end, options)</code> 方法来绘制弧。</p>
<p>这里的 <code>xy</code> 是一个长度为 4 的列表，用来表示一个 bounding box（参考上一篇文章）。<code>start</code> 和 <code>end</code> 则是弧的起止角度，单位是 °。其中水平向右的方向为 0°，竖直向下的方向为 90°，水平向左的方向为 180°，竖直向上的方向为 270°。</p>
<p><code>options</code> 中可用的选项有</p>
<ul>
<li><code>fill = (R, G, B)</code> - 用于指定线条的颜色，其中 <code>R</code>、<code>G</code>、<code>B</code> 都是 0 — 255 的整数</li>
</ul>
<p><code>arc</code> 方法将在内切于 bounding box 的椭圆中，按照给定的起止角度切下一段弧，并绘制于 <code>Image</code> 示例之上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">import</span> Image, ImageDraw
sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
drawAvatar     = ImageDraw.Draw(avatar)

xSize, ySize = avatar.size

drawAvatar.arc([<span class="number">0</span>, <span class="number">0</span>, xSize, ySize], <span class="number">0</span>, <span class="number">90</span>,\
    fill = (<span class="number">255</span>, <span class="number">100</span>, <span class="number">255</span>))
<span class="keyword">del</span> drawAvatar

avatar.show()
</pre></td></tr></table></figure>



<p><img src="/attachment/images/Python/pil-tutorial/draw-arc.png" alt="arc 方法效果示例 "></p>
<h3 id=" 在图片上写字 ">在图片上写字</h3>
<p><code>Draw</code> 类提供了 <code>text(position, string, options)</code> 方法，该方法可以在 <code>Image</code> 实例上写字。</p>
<p>需要说明的是，<code>position</code> 指定的是文本左上角的顶点，而不是文本中心。这里可用的 <code>options</code> 有</p>
<ul>
<li><code>font = ImageFont instance</code> - 指定字体，接受一个 <code>ImageFont</code> 的实例</li>
<li><code>fill = (R, G, B)</code> - 用于指定线条的颜色，其中 <code>R</code>、<code>G</code>、<code>B</code> 都是 0 — 255 的整数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">import</span> Image, ImageDraw
sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
drawAvatar     = ImageDraw.Draw(avatar)

xSize, ySize = avatar.size

drawAvatar.text([<span class="number">0.9</span> * xSize, <span class="number">0.1</span> * ySize - drawAvatar.textsize(<span class="string">"3"</span>)[<span class="number">1</span>]],\
    <span class="string">"3"</span>, fill = (<span class="number">128</span>, <span class="number">0</span>, <span class="number">128</span>))
<span class="keyword">del</span> drawAvatar

avatar.show()
</pre></td></tr></table></figure>



<p><img src="/attachment/images/Python/pil-tutorial/draw-text.png" alt="text 方法效果示例 "></p>
<p>由于没有用 <code>font</code> 选项指定字体，这里使用了 <code>ImageDraw</code> 的默认字体。不难发现，相对图片，字体太小了。为了调整字体，我们需要借助 <code>ImageFont</code> 模块。</p>
<h2 id="ImageFont_ 模块 "><code>ImageFont</code> 模块</h2>
<p><code>ImageFont</code> 模块很简单，它定义了一个同名的类。<code>ImageFont</code> 类的实例可以传给 <code>ImageDraw</code> 中 <code>text</code> 方法的 <code>font</code> 的参数，起到字体选择的作用。</p>
<p><code>ImageFont</code> 模块中的 <code>load</code> 函数可以加载一个 Image 格式的字体，并返回 <code>ImageFont</code> 实例；其中的 <code>truetype(fontfile, fontsize)</code> 函数则可以加载 TrueType 或 OpenType 格式的字体，并返回 <code>ImageFont</code> 参数。不过 <code>truetype</code> 函数需要额外安装 <code>_imagingft</code> 模块。</p>
<p>在 Mac 下的安装配置为：</p>
<pre><code><span class="built_in">sudo</span> chown -R <span class="variable">$USER</span>:admin /usr/local
brew install libtiff libjpeg libpng webp little-cms2 freetype
<span class="built_in">sudo</span> pip uninstall pil
<span class="built_in">sudo</span> pip install Pillow
</code></pre><p>这里我们用 <code>Pillow</code> 库替换了 <code>PIL</code> 库。这两个库本质是一样的，但是 <code>Pillow</code> 库提供了更多的功能和更简单的配置。</p>
<p>配置好之后，我们可以对上一节末尾的代码稍作修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont

sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
drawAvatar     = ImageDraw.Draw(avatar)

xSize, ySize = avatar.size
fontSize     = min(xSize, ySize) // <span class="number">11</span>

myFont       = ImageFont.truetype(<span class="string">"/Library/Fonts/OsakaMono.ttf"</span>, fontSize)

drawAvatar.text([<span class="number">0.9</span> * xSize, <span class="number">0.1</span> * ySize - fontSize],\
    <span class="string">"3"</span>, fill = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), font = myFont)
<span class="keyword">del</span> drawAvatar

avatar.show()
</pre></td></tr></table></figure>



<p>这里我们引入了 <code>ImageFont</code> 模块，并且创建了 <code>myFont</code> 实例。创建实例的时候，传入的字体尺寸由图片大小决定。最后在图片上写字的位置也与字体大小有关。</p>
<p>这样以来，我们就在图片的右上角写了一个红色的数字，就好像微信未读消息提示的那种效果。</p>
<p><img src="/attachment/images/Python/pil-tutorial/draw-text-font.png" alt=" 引入 font 选项的 text 方法效果示例 "></p>
<h2 id=" 小结 ">小结</h2>
<p><code>ImageDraw</code> 模块还有许多其他的功能，比如绘制椭圆、多边形、矩形等。限于篇幅，这里就不一一介绍了。感兴趣的读者可以参看官方文档：</p>
<p><a href="http://effbot.org/imagingbook/imagedraw.htm#methods" target="_blank">http://effbot.org/imagingbook/imagedraw.htm#methods</a></p>
]]></content>
    <summary type="html"><![CDATA[<p><a href="http://liam0205.me/2015/04/22/pil-tutorial-basic-usage/">上一篇文章</a> 介绍了 PIL 的基本情况，以及 <code>Image</code> 模块的基本用法。这篇文章，我们讨论一下 <code>ImageDraw</code> 和 <code>ImageFont</code> 两个模块的基本用法，说说如何用 PIL 在现有的图片上涂涂改改。</p>
]]></summary>
    
      <category term="Python" scheme="http://liam0205.me/tags/Python/"/>
    
      <category term="PIL" scheme="http://liam0205.me/tags/PIL/"/>
    
      <category term="ImageDraw" scheme="http://liam0205.me/tags/ImageDraw/"/>
    
      <category term="ImageFont" scheme="http://liam0205.me/tags/ImageFont/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[英语语法之三：动词时态]]></title>
    <link href="http://liam0205.me/2015/05/03/tense-of-verb/"/>
    <id>http://liam0205.me/2015/05/03/tense-of-verb/</id>
    <published>2015-05-03T10:06:39.000Z</published>
    <updated>2015-05-04T04:07:34.000Z</updated>
    <content type="html"><![CDATA[<p>这个系列的 <a href="http://liam0205.me/2014/06/22/noun-phrase-and-articles/">上一篇文章</a> 已经快一年了。我真是懒啊……</p>
<p>中文的谓语动词不在时间、状态、语态上作区分。在中文中，这些功能由其它副词提供。在英文中，动词的形态需要根据时间、状态、语态发生改变。对于中国人来说，这样的变化确实有些不自然；选错时态也是中国人讲英文时经常犯的错误。</p>
<p>在这里，语态和说话人的态度相关，比较容易感受。同时，语态反应在动词形态上的变化也相对简单，只需要加上合适的 <code>be</code> 动词，配上动词的过去分词即可。时态和动作发生的时间相关，也相对直观。因此，如果我们能对状态做一些简化，从状态出发去讨论时态，则问题会简单得多。</p>
<a id="more"></a>

<h2 id=" 状态的简化 ">状态的简化</h2>
<p>在现代英语中，状态分为</p>
<ul>
<li>一般状态（如：一般现在式）</li>
<li>进行状态（如：一般进行式）</li>
<li>完成状态（如：现在完成式）</li>
</ul>
<p>其中，进行状态的语法特征是 <code>be + 动词的现在分词（V-ing）</code>。如果我们「暂时忘掉」进行状态这个概念，把上述结构看做是 <code>be</code> 动词加上补语（表语）的结构，那这个结构和传统语法中的「一般状态」就没什么区别了。只不过，进行状态的动词是个 <code>be</code> 动词而已。也就是说，我们完全可以把进行状态看做是一种特殊的一般状态，它的谓语动词是个空的 <code>be</code> 动词。</p>
<p>因此，我们可以将一般状态和进行状态合并在一起，称之为「简单式」。为了统一称呼，我们把完成状态叫做「完成式」。</p>
<p>注意，这里的简化并不受语态影响。相对主动语态，被动语态不过是 <code>be + 动词的过去分词（V-ed）</code>而已。我们依然可以把被动语态当做 <code>be</code> 动词加上补语（表语）的结构。这样，语态完全不影响上述简化过程。</p>
<h2 id=" 简单式 ">简单式</h2>
<p>简单式有几个重要的特征：</p>
<ul>
<li><strong>简单式的动作，其发生的具体时间是一个特定的时间段</strong></li>
<li><strong>动作发生的时间段可大可小，可以延伸至无穷远的过去或无穷远的将来，也可以缩小至一个具体的时间点</strong></li>
<li><strong>如果动作发生的时间段</strong><ul>
<li>包括「现在」这个时间点，那么用现在时态</li>
<li>不包括「现在」这个时间点，且位于现在之前，那么用过去时态</li>
<li>不包括「现在」这个时间点，且位于现在之后，那么用将来时态</li>
</ul>
</li>
</ul>
<p>第一个特征，给了我们明确的信息来确定我们是否应该使用简单式（而不是完成式）。第二和第三个特征，则为我们选择时态提供了依据。</p>
<h3 id=" 过去时态 ">过去时态</h3>
<blockquote>
<p>The U.S.A <em>established</em> diplomatic relations with the P.R.C <em>in 1979</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>1979 年</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 <code>be</code> 动词</li>
</ul>
<p>因此，动词 <code>establish</code> 应该用过去式 <code>established</code>。这是传统语法的「一般过去式」。</p>
<blockquote>
<p>The movable print <em>was</em> introduced to England <em>in 1485</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>1979 年</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态</li>
<li>这里涉及到被动的语态，但不涉及到「持续」或者「正在发生」的含义，所以需要用 <code>be + V-ed</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的过去形态 <code>was</code>，以及 <code>introduced</code> 这个过去分词。这是传统语法的「一般过去式被动语态」。</p>
<blockquote>
<p>I <em>was</em> visiting clients <em>the whole day yesterday</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>昨天一整天</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态</li>
<li>这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 <code>be + V-ing</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的过去形态 <code>was</code>，以及 <code>visiting</code> 这个现在分词。这是传统语法的「过去进行式」。</p>
<blockquote>
<p>I <em>was</em> watching TV, <em>when I heard the door bell</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>听到门铃响的瞬间</em>，这是一个特定的时间段，退化为一个时间点，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态</li>
<li>这里不涉及到被动的语态，但涉及到「正在发生」的含义，所以需要用 <code>be + V-ing</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的过去形态 <code>was</code>，以及 <code>watching</code> 这个现在分词。这是传统语法的「过去进行式」。</p>
<blockquote>
<p>The witness <em>was</em> being questioned in court <em>when he had a heart attack</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>心脏病发作的瞬间</em>，这是一个特定的时间段，退化为一个时间点，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code>；同时，这里也涉及到「正在发生」的含义，所以需要用 <code>be + V-ing</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的过去形态 <code>was</code>，同时还需要 <code>being</code> 作为 <code>V-ing</code> 部分，然后还需要 <code>question</code> 的过去分词 <code>questioned</code>。这是传统语法的「过去进行式被动语态」。</p>
<h3 id=" 现在时态 ">现在时态</h3>
<blockquote>
<p>Obama <em>is</em> the U.S. President.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>几年前奥巴马上任之时到几年后奥巴马卸任之时</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段包括现在这个时间点，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们需要用 <code>is</code>。这是传统语法的「一般现在式」。</p>
<blockquote>
<p>Kyrie <em>steals</em> the ball and <em>passes</em> it to LeBron.</p>
</blockquote>
<ul>
<li>这是体育解说员在播报克利夫兰骑士队的比赛，动作发生的时间段是 <em>现在</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段包括现在这个时间点，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们分别需要用 <code>steal</code> 和 <code>pass</code> 单数第三人称形式 <code>steals</code> 和 <code>pass</code>。这是传统语法的「一般现在式」。</p>
<blockquote>
<p>All mothers <em>love</em> their children.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>无穷远的过去到无穷远的将来</em>，也就是所谓的真理，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段包括现在这个时间点，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们需要用 <code>love</code> 的原型。这是传统语法的「一般现在式」。</p>
<p>这就是为什么，传统语法说「真理要用一般现在式」。其实理解了我们的原理，就不需要被这些「特例」了。</p>
<blockquote>
<p>Walmart <em>is</em> selling big cokes at a discount <em>this mouth</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>这个月</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段包括现在这个时间点，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 <code>be + V-ing</code> 形式</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的单三形式 <code>is</code>，跟着 <code>sell</code> 的现在分词 <code>selling</code>。这是传统语法的「现在进行式」。</p>
<blockquote>
<p>According to the NASA survey, the ozone layer <em>is</em> being depleted.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>从臭氧层开始被消耗的时候到将来臭氧层不在被消耗的时候</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段包括现在这个时间点，所以应该用现在时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code>；同时，这里也涉及到「正在发生」的含义，所以需要用 <code>be + V-ing</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>be</code> 动词的单三形态 <code>is</code>，同时还需要 <code>being</code> 作为 <code>V-ing</code> 部分，然后还需要 <code>deplete</code> 的过去分词 <code>depleted</code>。这是传统语法的「现在进行式被动语态」。</p>
<h3 id=" 未来时态 ">未来时态</h3>
<blockquote>
<p>There <em>will be</em> a major election <em>in April</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>下一个四月份</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之后，所以应该用将来时态</li>
<li>这里不涉及到被动的语态，也不涉及到「正在发生」的含义，所以不需要额外的 <code>be</code></li>
</ul>
<p>因此，我们需要用 <code>will</code> 来表示将来时态，同时用 <code>be</code> 的原型，在这里表示「存在」的含义。这是传统语法的「一般将来式」。</p>
<blockquote>
<p>Don’t call me at <em>six tomorrow</em>. I <em>will</em> still <em>be</em> sleeping <em>then</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>明早六点</em>，这是一个特定的时间段，退化为一个时间点，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之后，所以应该用将来时态</li>
<li>这里不涉及到被动的语态，但不涉及到「正在发生」的含义，所以需要用 <code>be + V-ing</code> 的形态</li>
</ul>
<p>因此，我们需要用 <code>will</code> 来表示将来时态，用 <code>be</code> 动词的原型，同时接上 <code>sleep</code> 的现在分词 <code>sleeping</code>。这是传统语法的「将来进行式」。</p>
<blockquote>
<p>The building <em>will be</em> razed <em>next month</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间段是 <em>下个月</em>，这是一个特定的时间段，所以应该用简单式</li>
<li>这个时间段不包括现在这个时间点，且位于现在之后，所以应该用将来时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code> 的形态；但不涉及到「正在发生」的含义</li>
</ul>
<p>因此，我们需要用 <code>will</code> 来表示将来时态，用 <code>be</code> 动词的原型，同时接上 <code>raze</code> 的过去分词 <code>razed</code>。这是传统语法的「一般将来式被动语态」。</p>
<h2 id=" 完成式 ">完成式</h2>
<p>完成式也有几个重要的特征：</p>
<ul>
<li><strong>完成式的动作，其发生的时间有一个明确的截止时间点，表示「在这之前」或者「至此为止」</strong></li>
<li><strong>如果这个时间点</strong><ul>
<li>是「现在」这个时间点，那么用现在时态</li>
<li>是「过去」的某个时间点，那么用过去时态</li>
<li>是「将来」的某个时间点，那么用将来时态</li>
</ul>
</li>
</ul>
<p>第一个特征，给了我们明确的信息来确定我们是否应该使用完成式（而不是简单式）。第二个特征，则为我们选择时态提供了依据。</p>
<h3 id=" 现在时态 -1">现在时态</h3>
<blockquote>
<p>I’m sure that I <em>have seen</em> this face somewhere.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点，所以应该用完成式</li>
<li>截止时间点是「现在」，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们需要用 <code>have</code> 来表示完成时态，接上 <code>see</code> 的过去分词 <code>seen</code>。这是传统语法的「现在完成式」。</p>
<blockquote>
<p>We <em>have been</em> working overtime <em>for a week</em> to fill your order.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>至今已有一周</em>），所以应该用完成式</li>
<li>截止时间点是「现在」，所以应该用现在时态</li>
<li>这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 <code>be + V-ing</code> 的形式</li>
</ul>
<p>因此，我们需要用 <code>have</code> 来表示完成时态，接上 <code>be</code> 的过去分词 <code>been</code>，再加上 <code>work</code> 的现在分词 <code>working</code>。这是传统语法的「现在完成进行式」。</p>
<blockquote>
<p>The house <em>has been</em> redecorated twice since they moved in.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>从他们搬入<strong>到现在为止</strong></em>），所以应该用完成式</li>
<li>截止时间点是「现在」，所以应该用现在时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code> 的形式；但不涉及到「持续」的含义</li>
</ul>
<p>因此，我们需要用 <code>have</code> 的单三形式 <code>has</code> 来表示完成时态，接上 <code>be</code> 的过去分词 <code>been</code>，在加上 <code>redecorate</code> 的过去分词 <code>redecorated</code>。这是传统语法的「现在完成式被动语态」。</p>
<h3 id=" 过去时态 -1">过去时态</h3>
<p>一般来说，没有特别说明之时，说「在这之前」就是「在现在这个时间点之前」，所以需要用现在完成式。如果要用过去完成式，则需要有一个明确的过去时间截止点。</p>
<blockquote>
<p>Many soldiers <em>had died</em> from pneumonia <em>before the discovery of Penicilin</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>青霉素被发现之前</em>），所以应该用完成式</li>
<li>截止时间点是「过去」，所以应该用过去时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或「正在发生」的含义，所以不需要用额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们需要用 <code>have</code> 的过去式 <code>had</code> 表示过去完成式，接上 <code>die</code> 的过去分词 <code>died</code> 表示实际的动作。这是传统语法的「过去完成式」。</p>
<blockquote>
<p>I <em>had been</em> smoking three packs of cigarettes a day <em>before I decided to quit</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>我决定戒烟之前</em>），所以应该用完成式</li>
<li>截止时间点是「过去」，所以应该用过去时态</li>
<li>这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 <code>be + V-ing</code> 的形式</li>
</ul>
<p>因此，我们需要用 <code>have</code> 的过去式 <code>had</code> 表示过去完成式，接上 <code>be</code> 的过去分词 <code>been</code> 表示进行状态，最后加上 <code>smoke</code> 的现在分词 <code>smoking</code> 来表示实际的动作。这是传统语法的「过去完成进行式」。</p>
<blockquote>
<p>In the World War II, Japan <em>had not been</em> defeated yet <em>by the time Germany surrendered unconditionally</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>德国无条件投降之前</em>），所以应该用完成式</li>
<li>截止时间点是「过去」，所以应该用过去时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code> 的形式；但不涉及到「持续」或「正在发生」的含义</li>
</ul>
<p>因此，我们需要用 <code>have</code> 的过去式 <code>had</code> 表示过去完成式，接上 <code>be</code> 的过去分词 <code>been</code> 表示被动，最后加上 <code>defeat</code> 的现在分词 <code>defeated</code> 来表示实际的动作。这是传统语法的「过去完成式被动语态」。</p>
<h3 id=" 将来时态 ">将来时态</h3>
<p>和完成式的过去时态一样，将来时态中的完成式需要一个位于将来的时间截止点。</p>
<blockquote>
<p>Next April, I <em>will have worked</em> here for 2 years.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>到下个四月为止</em>），所以应该用完成式</li>
<li>截止时间点是「将来」，所以应该用将来时态</li>
<li>这里不涉及到被动的语态，也不涉及到「持续」或「正在发生」的含义，所以不需要用额外的 <code>be</code> 动词</li>
</ul>
<p>因此，我们需要用 <code>will have</code> 表示将来完成式，接上 <code>work</code> 的过去分词 <code>worked</code> 表示实际的动作。这是传统语法的「将来完成式」。</p>
<blockquote>
<p>Come back at 17:00. Your car <em>will have been</em> fixed <em>by then</em>.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>下午五点之前</em>），所以应该用完成式</li>
<li>截止时间点是「将来」，所以应该用将来时态</li>
<li>这里涉及到被动的语态，所以需要用 <code>be + V-ed</code> 的形式；但不涉及到「持续」或「正在发生」的含义</li>
</ul>
<p>因此，我们需要用 <code>will have</code> 表示将来完成式，接上 <code>be</code> 的过去分词 <code>been</code> 表示被动，再加上 <code>fix</code> 的过去分词 <code>fixed</code> 表示实际的动作。这是传统语法的「将来完成式被动语态」。</p>
<blockquote>
<p><em>In another two more minutes</em>, she <em>will have been</em> talking on the phone for three hours.</p>
</blockquote>
<ul>
<li>动作发生的时间不是一个特定的时间段，但有明确的截止时间点（<em>到两分钟之后</em>），所以应该用完成式</li>
<li>截止时间点是「将来」，所以应该用将来时态</li>
<li>这里不涉及到被动的语态，但不涉及到「持续」的含义，所以需要用 <code>be + V-ing</code> 的形式</li>
</ul>
<p>因此，我们需要用 <code>will have</code> 表示将来完成式，接上 <code>be</code> 的过去分词 <code>been</code> 表示进行，再加上 <code>talk</code> 的现在分词 <code>talking</code> 表示实际的动作。这是传统语法的「将来完成进行式」。</p>
]]></content>
    <summary type="html"><![CDATA[<p>这个系列的 <a href="http://liam0205.me/2014/06/22/noun-phrase-and-articles/">上一篇文章</a> 已经快一年了。我真是懒啊……</p>
<p>中文的谓语动词不在时间、状态、语态上作区分。在中文中，这些功能由其它副词提供。在英文中，动词的形态需要根据时间、状态、语态发生改变。对于中国人来说，这样的变化确实有些不自然；选错时态也是中国人讲英文时经常犯的错误。</p>
<p>在这里，语态和说话人的态度相关，比较容易感受。同时，语态反应在动词形态上的变化也相对简单，只需要加上合适的 <code>be</code> 动词，配上动词的过去分词即可。时态和动作发生的时间相关，也相对直观。因此，如果我们能对状态做一些简化，从状态出发去讨论时态，则问题会简单得多。</p>
]]></summary>
    
      <category term="English" scheme="http://liam0205.me/tags/English/"/>
    
      <category term="Grammar" scheme="http://liam0205.me/tags/Grammar/"/>
    
      <category term="Verb" scheme="http://liam0205.me/tags/Verb/"/>
    
      <category term="Tense" scheme="http://liam0205.me/tags/Tense/"/>
    
      <category term="Literature and Social Sciences" scheme="http://liam0205.me/categories/Literature%20and%20Social%20Sciences/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 hexo new 之后立即打开新建的 Markdown 文稿]]></title>
    <link href="http://liam0205.me/2015/05/01/open-editor-after-hexo-new-immediately/"/>
    <id>http://liam0205.me/2015/05/01/open-editor-after-hexo-new-immediately/</id>
    <published>2015-05-01T01:43:35.000Z</published>
    <updated>2015-05-01T02:32:25.000Z</updated>
    <content type="html"><![CDATA[<p>自己的博客是用 Hexo 搭建的。Hexo 是其时尚为大学生的台湾人 <a href="https://github.com/tommy351" target="_blank">Tommy</a> 开发的轻量级静态博客生成器，具有简洁、快速、扩展性好等特点。</p>
<p>在 Hexo 中新建一篇博文非常简单，只需要在命令行中执行</p>
<pre><code>hexo <span class="keyword">new</span> <span class="string">"the title of your blog"</span>
</code></pre><p>即可。Hexo 会在后台自动帮你创建名为 <code>yyyy-mm-dd-the-title-of-your-blog.md</code> 的文件，供你撰写博文。不过，也有不方便的地方。通常你需要依次打开 <code>hexo-home/source/_post</code> 目录，然后在成堆的 Markdown 文件中找到刚才创建的文档。</p>
<a id="more"></a>

<hr>
<p>简单搜索之后，我发现在 Hexo 的 GitHub 项目里，有人提出了类似的需求：</p>
<p><a href="https://github.com/hexojs/hexo/issues/1007" target="_blank">https://github.com/hexojs/hexo/issues/1007</a></p>
<p>Tommy 指出，可以在 Hexo 目录下的 <code>scripts</code> 目录（若没有，则新建一个）中创建一个 JavaScript 脚本，监听 <code>hexo new</code> 这个动作。并在检测到 <code>hexo new</code> 之后，执行编辑器打开的命令。</p>
<p>Tommy 给出的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;

<span class="comment">// Hexo 2.x</span>
hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span><span class="params">(path)</span>{</span>
  spawn(<span class="string">'vi'</span>, [path]);
});

<span class="comment">// Hexo 3</span>
hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>
  spawn(<span class="string">'vi'</span>, [data.path]);
});
</pre></td></tr></table></figure>



<p>我使用的 Hexo 是 2.5.4 版本，然而，测试过 Tommy 给出的代码之后并没有顺利地打开编辑器。不过精髓已经理解，需要的就只是细节的改变了。</p>
<p>简单翻阅了一下 JavaScript 的语法规则，我尝试了下列 JavaScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;

<span class="comment">// Hexo 2.x</span>
hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span><span class="params">(path)</span>{</span>
    exec(<span class="string">'open -a "/Applications/Sublime Text.app" '</span> + path);
});
</pre></td></tr></table></figure>



<blockquote>
<p>注意，我这里执行的系统命令，是 OS X 下的 <code>open</code>。换到 Windows 中，可能需要改为 <code>start</code>。</p>
</blockquote>
<hr>
<p>在命令行中敲下</p>
<pre><code>hexo <span class="keyword">new</span> <span class="string">"open editor after hexo new immediately"</span>
</code></pre><p>之后，Sublime Text 顺利打开了相应的 Markdown 文稿。接下来的事情，就是愉快地写作啦！</p>
]]></content>
    <summary type="html"><![CDATA[<p>自己的博客是用 Hexo 搭建的。Hexo 是其时尚为大学生的台湾人 <a href="https://github.com/tommy351" target="_blank">Tommy</a> 开发的轻量级静态博客生成器，具有简洁、快速、扩展性好等特点。</p>
<p>在 Hexo 中新建一篇博文非常简单，只需要在命令行中执行</p>
<pre><code>hexo <span class="keyword">new</span> <span class="string">"the title of your blog"</span>
</code></pre><p>即可。Hexo 会在后台自动帮你创建名为 <code>yyyy-mm-dd-the-title-of-your-blog.md</code> 的文件，供你撰写博文。不过，也有不方便的地方。通常你需要依次打开 <code>hexo-home/source/_post</code> 目录，然后在成堆的 Markdown 文件中找到刚才创建的文档。</p>
]]></summary>
    
      <category term="Hexo" scheme="http://liam0205.me/tags/Hexo/"/>
    
      <category term="Markdown" scheme="http://liam0205.me/tags/Markdown/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用合适的字体回退机制（Fallback）改善网页在 Windows 平台的字体显示效果]]></title>
    <link href="http://liam0205.me/2015/04/30/using-font-fallback-to-enhance-the-appreance-on-windows/"/>
    <id>http://liam0205.me/2015/04/30/using-font-fallback-to-enhance-the-appreance-on-windows/</id>
    <published>2015-04-30T09:18:40.000Z</published>
    <updated>2015-05-01T13:33:55.000Z</updated>
    <content type="html"><![CDATA[<p>昨天在群里提起 Windows 平台下坑爹的中易宋体之屏显效果，今日忽而想起自己的博客在 Windows 平台下显示的也是宋体。当然，这不是我的错。原本的字体机制，博客会按照顺序选择一款无衬线字体，直到无可选择时采用系统默认的无衬线字体。但是坑死人不偿命的云都死系统，把 SimSun （中易宋体）这个带有衬线（好吧，严格来说中文没有这个概念，我们跟着西文勉强这么称呼它）的字体也放进了系统 sans serif 字族里面去。其结果就是，不能丑陋更多。</p>
<p>作为一个强迫症患者，我们来看看如何修复这个问题。</p>
<a id="more"></a>

<h2 id=" 字体选择 ">字体选择</h2>
<p>配置字体回退机制，两个主要的原则就是：</p>
<ul>
<li>屏显效果好的字体放前面</li>
<li>适用范围小的字体放前面</li>
</ul>
<p>两条原则共同的作用就是：在尽可能多的平台下，获得相对更好的字体屏显效果。</p>
<p>对于中文来说，安装在作业系统中的主流黑体，屏显效果有大致如下的排序：</p>
<ul>
<li>Hiragino Sans GB - 冬青黑体</li>
<li>Source Han Sans CN - 思源黑体</li>
<li>Microsoft YaHei - 微软雅黑 (On Windows)</li>
<li>STXihei - 华文细黑</li>
<li>WenQuanYi Micro Hei - 文泉驿米黑</li>
<li>SimHei - 中易黑体</li>
</ul>
<p>其中冬青黑体和华文细黑，默认安装在 OS X 作业系统上；微软雅黑和中易黑体则主要安装在 Windows 作业系统上；思源黑体和文泉驿米黑则是 Linux 系统的主流中文黑体。</p>
<p>参考这一屏显效果排序，再结合一些实际情况（比如，在 OS X 作业系统中可能会因为安装 MS Office 而获得微软雅黑和中易宋体），我们给出了这样一个字体回退机制：</p>
<ol>
<li>Hiragino Sans GB</li>
<li>STXihei</li>
<li>Source Han Sans CN</li>
<li>Microsoft YaHei</li>
<li>WenQuanYi Micro Hei</li>
<li>SimHei</li>
</ol>
<p>这样，再加上西文的字体和系统默认的 <code>sans serif</code>，我们就得到了完整的字体回退列表：</p>
<pre><code>font<span class="attribute">-sans</span> <span class="subst">=</span> <span class="string">"Helvetica Neue"</span>, <span class="string">"Helvetica"</span>, <span class="string">"Hiragino Sans GB"</span>, <span class="string">"Source Han Sans CN"</span>, <span class="string">"STXihei"</span>, <span class="string">"Microsoft YaHei"</span>, <span class="string">"WenQuanYi Micro Hei"</span>, <span class="string">"SimHei"</span>, <span class="string">"Arial"</span>, sans<span class="attribute">-serif</span>
</code></pre><h2 id=" 修改 _modernist_ 主题的字体回退配置 ">修改 <code>modernist</code> 主题的字体回退配置</h2>
<p>网页的字体回退机制一般写在样式表（CSS）文件中。<code>hexo</code> 的样式表文件是从一些 <code>styl</code> 文件中产生的，每一个主题的 <code>styl</code> 文件结构都不大一样，所以这篇文章以我使用的 <code>modernist</code> 为准讲述。</p>
<p><code>modernist</code> 的作者很有心，将一些可能需要个性化配置的变量专门储存在名为 <code>variable.styl</code> 的文件里。这个文件位于 <code>./theme/modernist/source/css/_base/variable.styl</code>，我们打开它，然后将 <code>font-default</code> 和 <code>font-title</code> 的值改为：</p>
<pre><code><span class="string">"Helvetica Neue"</span>, <span class="string">"Helvetica"</span>, <span class="string">"Hiragino Sans GB"</span>, <span class="string">"Source Han Sans CN"</span>, <span class="string">"STXihei"</span>, <span class="string">"Microsoft YaHei"</span>, <span class="string">"WenQuanYi Micro Hei"</span>, <span class="string">"SimHei"</span>, <span class="string">"Arial"</span>, sans<span class="attribute">-serif</span>
</code></pre><p>之后，我们在命令行运行</p>
<pre><code>hexo clean <span class="subst">&amp;&amp;</span> hexo d <span class="attribute">-g</span>
</code></pre><p>就能将修复好的 CSS 文件推送到仓库了。</p>
<p>之后在 Windows 中打开，就会依照上述字体顺序去检索字体。对于新版的 Windows 系统，一般会以微软雅黑打开；对于旧版的 Windows 字体，一般会以中易黑体打开。</p>
]]></content>
    <summary type="html"><![CDATA[<p>昨天在群里提起 Windows 平台下坑爹的中易宋体之屏显效果，今日忽而想起自己的博客在 Windows 平台下显示的也是宋体。当然，这不是我的错。原本的字体机制，博客会按照顺序选择一款无衬线字体，直到无可选择时采用系统默认的无衬线字体。但是坑死人不偿命的云都死系统，把 SimSun （中易宋体）这个带有衬线（好吧，严格来说中文没有这个概念，我们跟着西文勉强这么称呼它）的字体也放进了系统 sans serif 字族里面去。其结果就是，不能丑陋更多。</p>
<p>作为一个强迫症患者，我们来看看如何修复这个问题。</p>
]]></summary>
    
      <category term="Hexo" scheme="http://liam0205.me/tags/Hexo/"/>
    
      <category term="Fonts" scheme="http://liam0205.me/tags/Fonts/"/>
    
      <category term="Fallback" scheme="http://liam0205.me/tags/Fallback/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Git 中 Checkout 历史版本]]></title>
    <link href="http://liam0205.me/2015/04/29/git-checkout-history-version/"/>
    <id>http://liam0205.me/2015/04/29/git-checkout-history-version/</id>
    <published>2015-04-29T00:44:56.000Z</published>
    <updated>2015-04-29T01:59:31.000Z</updated>
    <content type="html"><![CDATA[<p>昨天写代码的时候，误删了一个文件。今天发现的时候，commit 已经 push 到版本库了。本想用 <code>git reset</code> 回退版本，找回文件后重新提交。但是想起 Git 是一个版本控制系统哎，直接从版本库里 checkout 出某个文件的历史版本不就好了？</p>
<p>想法挺好，但是很久没用这个功能，自己已经不记得具体的命令了。于是查了下手册，把和 checkout 历史版本有关的几个命令都记录一下。</p>
<a id="more"></a>

<h3 id=" 从某个历史版本创建新的分支 ">从某个历史版本创建新的分支</h3>
<p>在 Git 中从当前分支创建并检出新分支的命令是</p>
<pre><code>git checkout <span class="attribute">-b</span> name<span class="attribute">-of</span><span class="attribute">-new</span><span class="attribute">-branch</span>
</code></pre><p>这个命令实际上是</p>
<pre><code>git checkout <span class="attribute">-b</span> name<span class="attribute">-of</span><span class="attribute">-new</span><span class="attribute">-branch</span> current<span class="attribute">-branch</span>
</code></pre><p>的简写形式。也就是说，当我们不指定 checkout 起点时，Git 默认从当前活动分支开始创建新的分支。</p>
<p>Git 的每个提交都有一个 SHA1 散列值（Hash 值）作为 ID。我们可以在 <code>checkout</code> 命令中使用这些 ID 作为起点。比如：</p>
<pre><code>git checkout <span class="attribute">-b</span> name<span class="attribute">-of</span><span class="attribute">-new</span><span class="attribute">-branch</span> <span class="number">169</span>d2dc
</code></pre><p>这样，Git 的活动分支会切换到 <code>name-of-new-branch</code> 这个分支上，而它的内容与 <code>169d2dc</code> 这个分支一致。</p>
<p>注意：SHA1 的散列值有 40 个字母，相当长。所以 Git 允许我们在不引起歧义的情况下，使用散列值的前几位作为缩写。</p>
<p>提示：你也可以用 <code>git branch name-of-new-branch 169d2dc</code> 来创建一个历史分支，而不切换到该分支。</p>
<h3 id=" 将某个历史版本 _checkout_ 到工作区 ">将某个历史版本 checkout 到工作区</h3>
<p>首先说明，这样做会产生一个分离的 HEAD 指针，所以个人不推荐这么做。</p>
<p>如果我们工作在 <code>master</code> 分支上，希望 checkout 到 <code>dev</code> 分支上，我们会这么做：</p>
<pre><code>git checkout dev
</code></pre><p>这里 <code>dev</code> 实际上是一个指针的别名，其本质也是一个 SHA1 散列值。所以，我们很自然地可以用</p>
<pre><code>git checkout <span class="subst">&lt;</span>sha1<span class="attribute">-of</span><span class="attribute">-a</span><span class="attribute">-commit</span><span class="subst">&gt;</span>
</code></pre><p>将某个历史版本 checkout 到工作区。</p>
<h3 id=" 将某个文件的历史版本 _checkout_ 到工作区 ">将某个文件的历史版本 checkout 到工作区</h3>
<p>大多数时候，我们可能只需要对某一个文件做细小的修补，因此只 checkout 该文件就行了，并不需要操作整个 commit 或分支。</p>
<p>上一节我们介绍了如何将某个历史版本完整地 checkout 到工作区。实际上，我们只需要在上一节的命令之后加上需要 checkout 的文件即可。</p>
<pre><code>git checkout &lt;sha1-<span class="operator">of</span>-<span class="operator">a</span>-commit&gt; &lt;/path/<span class="built_in">to</span>/your/<span class="built_in">file</span>&gt;
</code></pre><p>当然，有时候你需要将某个文件的历史版本 checkout 出来，并以一个新的名字保存。这时候可以这么做：</p>
<pre><code>git checkout &lt;sha1-of-a-commit&gt;<span class="symbol">:&lt;/path/to/your/file&gt;</span> &lt;<span class="regexp">/new/name</span><span class="regexp">/of/the</span><span class="regexp">/file&gt;</span>
</code></pre>]]></content>
    <summary type="html"><![CDATA[<p>昨天写代码的时候，误删了一个文件。今天发现的时候，commit 已经 push 到版本库了。本想用 <code>git reset</code> 回退版本，找回文件后重新提交。但是想起 Git 是一个版本控制系统哎，直接从版本库里 checkout 出某个文件的历史版本不就好了？</p>
<p>想法挺好，但是很久没用这个功能，自己已经不记得具体的命令了。于是查了下手册，把和 checkout 历史版本有关的几个命令都记录一下。</p>
]]></summary>
    
      <category term="Git" scheme="http://liam0205.me/tags/Git/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Apple 词典·再要你命 3000 | 美国传统大辞典 | Merriam Webster Collegiate Dict]]></title>
    <link href="http://liam0205.me/2015/04/24/apple-dictionaries-download/"/>
    <id>http://liam0205.me/2015/04/24/apple-dictionaries-download/</id>
    <published>2015-04-24T03:14:08.000Z</published>
    <updated>2015-04-28T23:42:40.000Z</updated>
    <content type="html"><![CDATA[<p>Apple 为 OS X 设计的词典非常好用，在不进行任何配置的情况下，就可以在全系统范围内进行选词查询。遗憾的是，Apple 并没有为用户提供太多可选的词典。</p>
<p>我用 Python 写了一个程序，将 Babylon 词典软件的 BGL 格式，转换为 Apple Dictionaries 的格式。由于 Babylon 的词典众多，于是 Apple 自带的词典也就多了起来。</p>
<a id="more"></a>

<p>这里转换好的有五个词典：</p>
<ul>
<li>再要你命 3000</li>
<li>美国传统大词典 英汉双解版</li>
<li>柯林斯高阶英汉双解学习词典</li>
<li>美林韦氏大学词典</li>
<li>英汉数学名词词典</li>
<li>英语用法词典</li>
</ul>
<p>下载后，将 ZIP 归档解包，将得到的 .dictionary 文件（实际上是文件夹）移动到下列目录：</p>
<pre><code>~<span class="regexp">/Library/</span><span class="constant">Dictionaries</span>
</code></pre><p>打开系统里的词典程序，在配置中，就能看到新增的词典了。</p>
<p>下载链接: <a href="http://pan.baidu.com/s/1gdIgK0b" target="_blank">http://pan.baidu.com/s/1gdIgK0b</a><br>提取密码: nsp0</p>
<p>文章已转载至知乎：<a href="http://www.zhihu.com/question/27098318/answer/46110189" target="_blank">http://www.zhihu.com/question/27098318/answer/46110189</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>Apple 为 OS X 设计的词典非常好用，在不进行任何配置的情况下，就可以在全系统范围内进行选词查询。遗憾的是，Apple 并没有为用户提供太多可选的词典。</p>
<p>我用 Python 写了一个程序，将 Babylon 词典软件的 BGL 格式，转换为 Apple Dictionaries 的格式。由于 Babylon 的词典众多，于是 Apple 自带的词典也就多了起来。</p>
]]></summary>
    
      <category term="3000" scheme="http://liam0205.me/tags/3000/"/>
    
      <category term="AHD" scheme="http://liam0205.me/tags/AHD/"/>
    
      <category term="Merriam Webster" scheme="http://liam0205.me/tags/Merriam%20Webster/"/>
    
      <category term="Apple Dictionaries" scheme="http://liam0205.me/tags/Apple%20Dictionaries/"/>
    
      <category term="GRE" scheme="http://liam0205.me/categories/GRE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PIL 简明教程 - 基本用法]]></title>
    <link href="http://liam0205.me/2015/04/22/pil-tutorial-basic-usage/"/>
    <id>http://liam0205.me/2015/04/22/pil-tutorial-basic-usage/</id>
    <published>2015-04-22T09:46:31.000Z</published>
    <updated>2015-04-23T15:15:08.000Z</updated>
    <content type="html"><![CDATA[<p>PIL (Python Image Library) 是 Python 平台处理图片的事实标准，兼具强大的功能和简洁的 API。这篇文章将从 PIL 的安装开始，介绍 PIL 的基本情况和基本用法。</p>
<a id="more"></a>

<h2 id=" 安装 ">安装</h2>
<p>在安装好了 Python 的基础上，安装 Python 十分简单。在 *nix 系统里，可以直接使用 Python 的包管理器来安装。例如使用 <code>easy_install</code> 安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">sudo</span> easy_install PIL
</pre></td></tr></table></figure>



<p>在 Windows 系统里，可以直接安装 <code>.exe</code> 版本。你可以在 <a href="http://pythonware.com/products/pil/" target="_blank">PIL 的官网</a> 下载到它。</p>
<p>安装好之后，打开 Python 解释器，输入 <code>import Image</code> 来测试是否安装成功。</p>
<h2 id=" 新建一个 _Image_ 类的实例 ">新建一个 <code>Image</code> 类的实例</h2>
<p>PIL 的主要功能定义在 <code>Image</code> 类当中，而 <code>Image</code> 类定义在同名的 <code>Image</code> 模块当中。使用 PIL 的功能，一般都是从新建一个 <code>Image</code> 类的实例开始。新建 <code>Image</code> 类的实例有多种方法。你可以用 <code>Image</code> 模块的 <code>open()</code> 函数打开已有的图片档案，也可以处理其它的实例，或者从零开始构建一个实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">import</span> Image
sourceFileName = <span class="string">"source.png"</span>
avatar         = Image.open(sourceFileName)
</pre></td></tr></table></figure>



<p>上述代码引入了 Image 模块，并以 <code>open()</code> 方法打开了 <code>source.png</code> 这个图像，构建了名为 <code>avatar</code> 的实例。如果打开失败，则会抛出 <code>IOError</code> 异常。</p>
<p>接下来你可以使用 <code>show()</code> 方法来查看实例。注意，PIL 会将实例暂存为一个临时文件，而后打开它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>avatar.show()
</pre></td></tr></table></figure>



<p><img src="/attachment/images/Python/pil-tutorial/Image_show.png" alt=" 使用 `show()` 方法查看实例的内容 "></p>
<h2 id=" 查看实例的属性 ">查看实例的属性</h2>
<p><code>Image</code> 类的实例有 5 个属性，分别是：</p>
<ul>
<li><code>format</code>: 以 <code>string</code> 返回图片档案的格式（<code>JPG</code>, <code>PNG</code>, <code>BMP</code>, <code>None</code>, etc.）；如果不是从打开文件得到的实例，则返回 <code>None</code>。</li>
<li><code>mode</code>: 以 <code>string</code> 返回图片的模式（RGB, CMYK, etc.）；完整的列表参见 <a href="http://effbot.org/imagingbook/concepts.htm#mode" target="_blank">官方说明·图片模式列表</a></li>
<li><code>size</code>: 以二元 tuple 返回图片档案的尺寸 (width, height)</li>
<li><code>palette</code>: 仅当 <code>mode</code> 为 <code>P</code> 时有效，返回 <code>ImagePalette</code> 示例</li>
<li><code>info</code>: 以字典形式返回示例的信息</li>
</ul>
<p>我们接着上面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">print</span> avatar.format, avatar.size, avatar.mode
</pre></td></tr></table></figure>



<p><img src="/attachment/images/Python/pil-tutorial/Image_attrib.png" alt=" 查看示例的属性 "></p>
<p>这里我们看到返回了图片的格式 <code>PNG</code>、图片的大小 <code>(400, 400)</code> 和图片的模式 <code>RGB</code>。</p>
<h2 id=" 实例的方法 ">实例的方法</h2>
<p><code>Image</code> 类定义了许多方法，这里无法一一列出（也无必要）。如果有需要，可以参看 <a href="http://effbot.org/imagingbook/image.htm" target="_blank">官方说明·<code>Image</code> 模块</a>。这里仅列出几个有趣的应用。</p>
<h3 id=" 图片 _IO_-_ 转换图片格式 ">图片 IO - 转换图片格式</h3>
<p><code>Image</code> 模块提供了 <code>open()</code> 函数打开图片档案，<code>Image</code> 类则提供了 <code>save()</code> 方法将图片实例保存为图片档案。</p>
<p><code>save()</code> 函数可以以特定的图片格式保存图片档案。比如 <code>save(&#39;target.jpg&#39;, &#39;JPG&#39;)</code> 将会以 <code>JPG</code> 格式将图片示例保存为 <code>target.jpg</code>。不过，大多数时候也可以省略图片格式。此时，<code>save()</code> 方法会根据文件扩展名来选择相应的图片格式。</p>
<p>我们以一个转换图片格式的脚本进行分析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">import</span> os, sys
<span class="keyword">import</span> Image

<span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:
    f, e = os.path.splitext(infile)
    outfile = f + <span class="string">".jpg"</span>
    <span class="keyword">if</span> infile != outfile:
        <span class="keyword">try</span>:
            Image.open(infile).save(outfile)
        <span class="keyword">except</span> IOError:
            <span class="keyword">print</span> <span class="string">"cannot convert"</span>, infile
</pre></td></tr></table></figure>



<p>这里，<code>f</code> 是除去扩展名之外的文件名。在 <code>try</code> 语句中，我们尝试打开图片档案，然后以 <code>.jpg</code> 为扩展名保存图片档案。<code>save()</code> 方法会根据扩展名，将图片以 <code>JPG</code> 格式保存为档案。如果图片档案无法打开，则在终端上打印无法转换的消息。</p>
<h3 id=" 制作缩略图 ">制作缩略图</h3>
<p><code>Image</code> 类的 <code>thumbnail()</code> 方法可以用来制作缩略图。它接受一个二元数组作为缩略图的尺寸，然后将示例缩小到指定尺寸。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">import</span> os, sys
<span class="keyword">import</span> Image

<span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:
    outfile = os.path.splitext(infile)[<span class="number">0</span>] + <span class="string">".thumbnail"</span>
    <span class="keyword">if</span> infile != outfile:
        <span class="keyword">try</span>:
            im   = Image.open(infile)
            x, y = im.size
            im.thumbnail((x//<span class="number">2</span>, y//<span class="number">2</span>))
            im.save(outfile, <span class="string">"JPEG"</span>)
        <span class="keyword">except</span> IOError:
            <span class="keyword">print</span> <span class="string">"cannot create thumbnail for"</span>, infile
</pre></td></tr></table></figure>



<p>这里我们用 <code>im.size</code> 获取原图档的尺寸，然后以 <code>thumbnail()</code> 制作缩略图，大小则是原先图档的四分之一。同样，如果图档无法打开，则在终端上打印无法执行的提示。</p>
<h3 id=" 剪裁图档 ">剪裁图档</h3>
<p>以前也写过 <a href="http://liam0205.me/2014/01/27/Py-Incise-Images/">一篇博客</a>，讲述如何用 PIL 批量剪裁图档，供参考。</p>
<h3 id=" 变形与粘贴 ">变形与粘贴</h3>
<p><code>transpose()</code> 方法可以将图片左右颠倒、上下颠倒、旋转 90°、旋转 180° 或旋转 270°。<code>paste()</code> 方法则可以将一个 <code>Image</code> 示例粘贴到另一个 <code>Image</code> 示例上。</p>
<p>我们尝试将一张图片的左半部分截取下来，左右颠倒之后旋转 180°；将图片的右半边不作更改粘贴到左半部分；最后将修改过的左半部分粘贴到右半部分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">import</span> Image

imageFName = <span class="string">'source.png'</span>

<span class="function"><span class="keyword">def</span> <span class="title">iamge_transpose</span><span class="params">(image)</span>:</span>
    <span class="string">'''
        Input: a Image instance
        Output: a transposed Image instance
        Function:
            * switches the left and the right part of a Image instance
            * for the left part of the original instance, flips left and right\
                and then make it upside down.
    '''</span>
    xsize, ysize = image.size
    xsizeLeft    = xsize // <span class="number">2</span> <span class="comment"># while xsizeRight = xsize - xsizeLeft</span>

    boxLeft      = (<span class="number">0</span>, <span class="number">0</span>, xsizeLeft, ysize)
    boxRight     = (xsizeLeft, <span class="number">0</span>, xsize, ysize)
    boxLeftNew   = (<span class="number">0</span>, <span class="number">0</span>, xsize - xsizeLeft, ysize)
    boxRightNew  = (xsize - xsizeLeft, <span class="number">0</span>, xsize, ysize)

    partLeft     = image.crop(boxLeft).transpose(Image.FLIP_LEFT_RIGHT).\
        transpose(Image.ROTATE_180)
    partRight    = image.crop(boxRight)

    image.paste(partRight, boxLeftNew)
    image.paste(partLeft, boxRightNew)
    <span class="keyword">return</span> image

avatar = Image.open(imageFName)
avatar = iamge_transpose(avatar)
avatar.show()
</pre></td></tr></table></figure>



<p><code>image_transpose()</code> 函数定义之前的部分很简单，而函数本身也由文档叙述得比较清楚。</p>
<p>这里我们以 <code>xsize</code> 和 <code>ysize</code> 接收图片的宽和高，然后以 <code>xsizeLeft</code> 计算得到左半边图片的大小。需要注意的是，我们构建了四个元组，并命名为盒子。这个盒子用直角坐标的值在 <code>image</code> 的画布上框定了一个区域。注意，<code>Image</code> 模块以图片的左上角为直角坐标原点，向右为 <code>x</code> 轴正方向，向下为 <code>y</code> 轴正方向。元组中的前两个数，代表区域左上角的坐标值；后两个数代表区域右下角的坐标值。</p>
<p>接下来的代码相当易懂。我们先用 <code>crop()</code> 方法将原图 <code>boxLeft</code> 的区域（也就是原图的左半边）切下来，然后用 <code>transpose()</code> 方法先后进行左右颠倒和旋转 180° 的工作，并最周公将它保存在 <code>partLeft</code> 这个实例中。而 <code>partRight</code> 的操作更为简单。</p>
<p>函数的最后，我们用 <code>paste()</code> 方法，将前两步得到的 <code>partLeft</code> 和 <code>partRight</code> 分别粘贴到指定的区域；并最终返回 <code>image</code> 示例。</p>
<p>代码片段的最后，我们用 <code>show()</code> 方法展示图片。</p>
<p><img src="/attachment/images/Python/pil-tutorial/transpose_paste.png" alt=" 变形和旋转 "></p>
]]></content>
    <summary type="html"><![CDATA[<p>PIL (Python Image Library) 是 Python 平台处理图片的事实标准，兼具强大的功能和简洁的 API。这篇文章将从 PIL 的安装开始，介绍 PIL 的基本情况和基本用法。</p>
]]></summary>
    
      <category term="Python" scheme="http://liam0205.me/tags/Python/"/>
    
      <category term="PIL" scheme="http://liam0205.me/tags/PIL/"/>
    
      <category term="Image" scheme="http://liam0205.me/tags/Image/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[避免 \chapter 命令分页]]></title>
    <link href="http://liam0205.me/2015/04/22/cancle-clearpage-in-chapter/"/>
    <id>http://liam0205.me/2015/04/22/cancle-clearpage-in-chapter/</id>
    <published>2015-04-22T01:39:26.000Z</published>
    <updated>2015-04-22T02:14:27.000Z</updated>
    <content type="html"><![CDATA[<p>LaTeX 的 <code>book</code> 类中，<code>\chapter</code> 命令用来标记章节。在生成的 PDF 文稿中，<code>\chapter</code> 总是另起一页；在打开（默认）<code>openright</code> 选项的时候，可能还会空白一页。在实际使用过程中，很多人希望 <code>\chapter</code> 不要换页，紧接着当前页的内容排版。</p>
<p>传统工具没有提供此功能，因此用户需要自行修改 <code>\chapter</code> 的定义。</p>
<a id="more"></a>

<h2 id=" 找到 _\chapter_ 的定义 ">找到 <code>\chapter</code> 的定义</h2>
<p>LaTeX 标准文档类的定义写在 <code>classes.pdf</code> 这个文档中，你可以在命令行下使用 <code>texdoc classes</code> 来打开这份文档。</p>
<p>你可以在文档的 7.2.6 节中找到 <code>\chapter</code> 的定义。和我们的问题相关的，就是 <code>\chapter</code> 定义的第一行。</p>
<p><img src="/images/LaTeX/def-of-chapter.png" alt="`\chapter` 的定义 "></p>
<p>得益于 <a href="http://liam0205.me/2015/01/23/literate-programming-in-latex/">文学编程</a>，我们看到文档中明确地写着「章节总是应该从新的一页开始，因此我们需要调用 <code>\clearpage</code>」。</p>
<p>显然，为了达到目的，我么只需要令 <code>\chapter</code> 定义的第一行失效就好了。</p>
<h2 id=" 打补丁 ">打补丁</h2>
<p><code>xpatch</code> 宏包可以用来打补丁。它的 <code>\xpatchcmd</code> 命令接受五个参数：<code>\xpatchcmd{命令}{搜索}{替换}{成功}{失败}</code></p>
<ul>
<li><code>命令</code>：待处理的命令</li>
<li><code>搜索</code>：需要被替换的部分</li>
<li><code>替换</code>：将被替换的内容</li>
<li><code>成功</code>：替换成功执行的内容</li>
<li><code>失败</code>：替换失败执行的内容</li>
</ul>
<p>这里我们需要将 <code>\if@openright\cleardoublepage\else\clearpage\fi</code> 替换掉。用于替换的内容则是：<code>\par\relax</code>。因此我们有代码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="command">\usepackage</span><span class="special">{</span>xpatch<span class="special">}</span>
<span class="command">\makeatletter</span>
<span class="command">\xpatchcmd</span><span class="special">{</span><span class="command">\chapter</span><span class="special">}</span>
  <span class="special">{</span><span class="command">\if</span>@openright<span class="command">\cleardoublepage</span><span class="command">\else</span><span class="command">\clearpage</span><span class="command">\fi</span><span class="special">}</span><span class="special">{</span><span class="command">\par</span><span class="command">\relax</span><span class="special">}</span>
  <span class="special">{</span><span class="special">}</span><span class="special">{</span><span class="special">}</span>
<span class="command">\makeatother</span>
</pre></td></tr></table></figure>



<p>注意，符号 <code>@</code> 是一个保留符号。它在用户编写 <code>.tex</code> 文档的时候和开发者编写宏包 / 文档类的时候具有不同含义。我们用 <code>\makeatletter</code> 将 <code>@</code> 的含义切换到开发者模式；在进行修改之后，用 <code>\makeatother</code> 将 <code>@</code> 的含义切换到用户模式。</p>
<p>这样，<code>\chapter</code> 定义中的换行部分，就被替换成了分段。</p>
<p>完整的示例代码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>book<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>xpatch<span class="special">}</span>
<span class="command">\makeatletter</span>
<span class="command">\xpatchcmd</span><span class="special">{</span><span class="command">\chapter</span><span class="special">}</span>
  <span class="special">{</span><span class="command">\if</span>@openright<span class="command">\cleardoublepage</span><span class="command">\else</span><span class="command">\clearpage</span><span class="command">\fi</span><span class="special">}</span><span class="special">{</span><span class="command">\par</span><span class="command">\relax</span><span class="special">}</span>
  <span class="special">{</span><span class="special">}</span><span class="special">{</span><span class="special">}</span>
<span class="command">\makeatother</span>
<span class="command">\usepackage</span><span class="special">{</span>blindtext<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\blindtext</span>
<span class="command">\chapter</span><span class="special">{</span>test<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>


]]></content>
    <summary type="html"><![CDATA[<p>LaTeX 的 <code>book</code> 类中，<code>\chapter</code> 命令用来标记章节。在生成的 PDF 文稿中，<code>\chapter</code> 总是另起一页；在打开（默认）<code>openright</code> 选项的时候，可能还会空白一页。在实际使用过程中，很多人希望 <code>\chapter</code> 不要换页，紧接着当前页的内容排版。</p>
<p>传统工具没有提供此功能，因此用户需要自行修改 <code>\chapter</code> 的定义。</p>
]]></summary>
    
      <category term="Chapter" scheme="http://liam0205.me/tags/Chapter/"/>
    
      <category term="Pagebreak" scheme="http://liam0205.me/tags/Pagebreak/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 MacTeX 中使用中文模板]]></title>
    <link href="http://liam0205.me/2015/04/14/using-chinese-templates-in-mactex/"/>
    <id>http://liam0205.me/2015/04/14/using-chinese-templates-in-mactex/</id>
    <published>2015-04-14T09:52:30.000Z</published>
    <updated>2015-04-14T11:54:37.000Z</updated>
    <content type="html"><![CDATA[<p>中国人使用 LaTeX 的一大问题就是为文档添加中文支持。国内很多学校、期刊都有自己的模板，更多的是一些个人配置的勉强成型的小模板。Mac 用户安装 MacTeX 之后，可能会很头疼如何将这些模板移植到自己的电脑上。这篇文章对此做一个方法上的讨论。</p>
<a id="more"></a>

<p>在 LaTeX 中使用中文，<strong>不严谨地说</strong>，主要需要解决编码和字体调用的问题。</p>
<p>国内 LaTeX 圈子流行过 GBK 编码和 UTF-8 编码。前者是国标，是过去的主流，但是问题多多。现在推荐使用后者。</p>
<p>字体调用方面，原来的 <code>CCT</code>（新版）、<code>CJK</code> 还有现在的 <code>xeCJK</code>、<code>LuaTeX-ja</code> 和李阿玲的 pTeX-ng 在 TeX Live（MacTeX）底下都能正常工作。只不过，Mac 默认的字体和 Windows 默认的字体有一些不同，在这方面需要做一些调整。</p>
<p>国内期刊的模板大多数是 <code>CCT</code> 和 <code>CJK</code> 方式，其他一些模板可能比较先进，使用 <code>xeCJK</code> 方式。<code>LuaTeX-ja</code> 国内用的少，使用方法和 <code>xeCJK</code> 比较类似；pTeX-ng 尚在开发中。所以这里只介绍使用 <code>CCT</code>、<code>CJK</code> 或 <code>xeCJK</code> 三种中文支持方式在 TeX Live 里如何进行调整。</p>
<h2 id="xeCJK"><code>xeCJK</code></h2>
<p><code>xeCJK</code> 通过 <code>\setCJKmainfont</code> 等命令（<code>luatexja-fontspec</code> 则是 <code>\setmainjfont</code>）来调用操作系统内的字体，并设置为文档字体。在 Windows 底下编写的中文模板，惯常使用 Windows 自带的中易系列字体，比如</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="command">\setCJKmainfont</span><span class="special">[</span>Boldfont = SimHei, ItalicFont = KaiTi<span class="special">]</span><span class="special">{</span>SimSun<span class="special">}</span>
<span class="command">\setCJKsansfont</span><span class="special">{</span>SimHei<span class="special">}</span>
<span class="command">\setCJKmonofont</span><span class="special">{</span>FangSong<span class="special">}</span>
</pre></td></tr></table></figure>



<p>这种情况下，可以打开模板文件（<code>.tex</code>、<code>.sty</code> 或 <code>.cls</code>），找到字体设置部分，将其内容改为 Mac 的字体设置即可。比如可以参考配置：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="command">\setCJKmainfont</span><span class="special">[</span>BoldFont=STZhongsong, ItalicFont=STKaiti<span class="special">]</span><span class="special">{</span>STSong<span class="special">}</span>
<span class="command">\setCJKsansfont</span><span class="special">[</span>BoldFont=STHeiti<span class="special">]</span><span class="special">{</span>STXihei<span class="special">}</span>
<span class="command">\setCJKmonofont</span><span class="special">{</span>STFangsong<span class="special">}</span>
</pre></td></tr></table></figure>



<p>具体的含义可参考：<a href="http://liam0205.me/2014/11/02/latex-mactex-chinese-support/">为 MacTeX 配置中文支持</a></p>
<p>使用 <code>xeCJK</code> 的模板，应该都保存为 UTF-8 编码，所以不需要进行编码调整。<br>（部分模板使用 GBK 编码，在文档头会有 <code>\XeTeXinputencoding &#39;CP936&#39;</code> 的 XeTeX 原语。此时最好将文件另存为 UTF-8 编码，并删除这些原语。）</p>
<h2 id="CJK"><code>CJK</code></h2>
<p>在不适用 <code>zhmetrics</code> 技术的时候，<code>CJK</code> 需要 Type 1 字体。将中易字体拆分成许多 sub-fonts 并转换为 Type 1 字体是个费时费力的工作。CTeX 套装打包了已经配置好的 CJK 字体，它的 song、hei、kai、fs、li 和 you 等六套字体，流传甚广。国内使用 <code>CJK</code> 的模板，大都使用了这几套字体。</p>
<p>不过，<code>CJK</code> 宏包本身并不含有这些字体，所以在使用 TeX Live 的时候，直接编译这些模板会报错。</p>
<p>我们看一段最简单的使用 <code>CJK</code> 宏包做中文支持的例子。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>article<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>CJKutf8<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>CJK*<span class="special">}</span><span class="special">{</span>UTF8<span class="special">}</span><span class="special">{</span>song<span class="special">}</span>
中文。
<span class="command">\clearpage</span>
<span class="command">\end</span><span class="special">{</span>CJK*<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>对于 Windows 系统的 TeX Live 用户而言，最简单的办法是使用 <code>zhmetrics</code> 技术。为此我们只需要在导言区添加一行命令即可，代码变为：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>article<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>CJKutf8<span class="special">}</span>
<span class="command">\AtBeginDvi</span><span class="special">{</span><span class="command">\input</span><span class="special">{</span>zhwinfonts<span class="special">}</span><span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>CJK*<span class="special">}</span><span class="special">{</span>UTF8<span class="special">}</span><span class="special">{</span>song<span class="special">}</span>
中文。
<span class="command">\clearpage</span>
<span class="command">\end</span><span class="special">{</span>CJK*<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>此时，使用 pdfLaTeX 或 LaTeX - DVIPDFMx 编译文档，即可得到正确的结果。</p>
<p>对于 Mac/Linux 系统的 TeX Live（MacTeX）用户而言，简单地加载 <code>zhwinfonts.tex</code> 是不会奏效的。<code>zhwinfonts.tex</code> 是为 Windows 系统配置的文件，在 Mac/Linux 系统中缺少这些字体。我自己买了方正系列字体在 Mac 上使用，所以写了一个 <code>zhfzfonts.tex</code> 来调用这些字体。</p>
<p>需要做的事情：</p>
<ol>
<li>安装下列字体（涉及到版权，这里就不提供了）<ul>
<li>方正书宋 GBK：FZSSK.TTF</li>
<li>方正楷体 GBK：FZKTK.TTF</li>
<li>方正黑体 GBK：FZHTK.TTF</li>
<li>方正仿宋 GBK：FZFSK.TTF</li>
<li>华文隶体：STLITI.ttf（Mac 自带）</li>
<li>华文琥珀：STHUPO.TTF（Mac 自带）</li>
</ul>
</li>
<li>下载 <a href="http://liam0205.me/attachment/LaTeX-useful-tools/zhfzfonts.tex"><code>zhfzfonts.tex</code></a></li>
<li>将 <code>zhfzfonts.tex</code> 保存在 <code>TEXMFLOCAL/tex/generic/zhmetrics/</code> 目录下</li>
<li>使用 texhash 刷新文件名数据库（可能需要 root 权限）</li>
<li>调整代码</li>
</ol>
<p>这里 TEXMFLOCAL 指的是 TeX Live 供用户使用的 TDS 根目录，在 MacTeX 里是 <code>/usr/local/texlive/texmf-local</code>。</p>
<p><code>CJK</code> 支持 GBK，也支持 UTF-8。请注意将文档编码保存为与 <code>CJK</code> 环境相同的编码格式。</p>
<h2 id="CCT"><code>CCT</code></h2>
<p>以系统工程理论与实践为代表的一些国内期刊，使用 <code>CCT</code> 模板。前年为此写过一篇博客，专门讨论此类模板。参见：<a href="http://liam0205.me/2013/10/15/LaTeX-CCT-template/">国内期刊 CCT 模板编译经验</a></p>
<p><code>CCT</code> 只支持 GBK 编码。</p>
<h2 id="ctex_ 宏包 / 文档类 "><code>ctex</code> 宏包 / 文档类</h2>
<p><code>ctex</code> 宏包 / 文档类在使用 XeLaTeX 编译的时候，使用 <code>xeCJK</code> 作为中文支持方式；在使用 LaTeX/pdfLaTeX 的时候使用 <code>CJK</code> 作为中文支持方式。因此，使用 <code>ctex</code> 宏包 / 文档类的模板，在 TeX Live 系统下的配置方式需要根据所选的编译方式做调整。</p>
<p>使用 XeLaTeX 的时候，需要给 <code>ctex</code> 加上 <code>nofonts</code> 选项（将来的 2.0 版本则是 fontset = none），然后再用 <code>\setCJKmainfont</code> 配置字体。</p>
<p>使用 LaTeX/pdfLaTeX 的时候，则可以使用 <code>zhfzfonts.tex</code> 来映射字体。</p>
<p>使用 <code>ctex</code> 宏包 / 文档类的时候，需要根据所选的编译方式和宏包 / 文档类选项来确定源文件的编码格式。</p>
<ul>
<li>使用 XeLaTeX 的时候，不论选项为何，源文件都需要保存为 UTF-8 编码。</li>
<li>使用 LaTeX/pdfLaTeX 的时候，则需要根据宏包 / 文档类选项来确定源文件的编码格式。</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>中国人使用 LaTeX 的一大问题就是为文档添加中文支持。国内很多学校、期刊都有自己的模板，更多的是一些个人配置的勉强成型的小模板。Mac 用户安装 MacTeX 之后，可能会很头疼如何将这些模板移植到自己的电脑上。这篇文章对此做一个方法上的讨论。</p>
]]></summary>
    
      <category term="Template" scheme="http://liam0205.me/tags/Template/"/>
    
      <category term="Chinese" scheme="http://liam0205.me/tags/Chinese/"/>
    
      <category term="MacTeX" scheme="http://liam0205.me/tags/MacTeX/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 LaTeX 中将不编号的章节列入目录]]></title>
    <link href="http://liam0205.me/2015/04/10/how-to-list-unnumbered-section-in-the-table-of-contents/"/>
    <id>http://liam0205.me/2015/04/10/how-to-list-unnumbered-section-in-the-table-of-contents/</id>
    <published>2015-04-10T09:54:32.000Z</published>
    <updated>2015-04-10T10:41:32.000Z</updated>
    <content type="html"><![CDATA[<p>LaTeX 标准文档类提供了 <code>\section</code> 和 <code>\section*</code> 等两组命令，用于排版章节标题。其中不带星号的版本有章节编号，会列入目录，同时修改章节标记。带星号的版本只有章节标题格式而不编号，不列入目录，也不会修改章节标记。</p>
<p>有时，我们会希望将不编号的章节标题列入目录。这种情况使用 <code>\section</code> 或 <code>\section*</code> 都不大合适。本文将对这些问题做出分析，并给出解决方案。</p>
<a id="more"></a>

<p>LaTeX 标准文档类的 <code>\section</code> 命令做四件事情：</p>
<ol>
<li>编号自增 1</li>
<li>输出章节标题</li>
<li>处理目录（和 PDF 书签）</li>
<li>做页眉的章节标记</li>
</ol>
<p>相应地，<code>\section*</code> 命令只做上述第二件事情，其余三件都不做。</p>
<p>因此，我们的思路很简单，有两个方向。第一，使用 <code>\section*</code>，手工做目录的处理；第二，使用 <code>\section</code>，但是抑制编号。</p>
<h2 id=" 思路一 ">思路一</h2>
<p>LaTeX 处理目录需要编译两次。在第一次编译的过程中，<code>\section</code> 命令将目录信息写入 <code>.aux</code> 文件。随后，在第二次编译的过程中，LaTeX 读取 <code>.aux</code> 文件中的相应信息，形成目录。因此，我们只需要模仿 <code>\section</code> 写入 <code>.aux</code> 文件的过程就可以了。</p>
<p>LaTeX 提供了 <code>\addcontentsline{&lt; 辅助文件后缀 &gt;}{&lt; 章节等级 &gt;}{名字}</code> 命令来做这样的工作。我们来看一个例子。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>ctexart<span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\tableofcontents</span>
<span class="command">\section*</span><span class="special">{</span>不编号的章节标题<span class="special">}</span>
<span class="command">\addcontentsline</span><span class="special">{</span>toc<span class="special">}</span><span class="special">{</span>section<span class="special">}</span><span class="special">{</span>不编号的章节标题<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<h2 id=" 思路二 ">思路二</h2>
<p>LaTeX 标准文档类中的 <code>\appendix</code> 命令，会使得后续的章节标题从 0 开始编号，同时将编号格式从阿拉伯数字修改为大写英文字母。<code>\appendix</code> 命令虽然不符合我们的需求，但是产生的效果却和我们需要的效果类似：修改了章节标题编号。我们可以对这个命令做适当的修改，达成我们的目的。</p>
<p>我们来看一下 <code>article.cls</code> 里的 <code>\appendix</code> 是如何定义的。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="command">\newcommand</span><span class="command">\appendix</span><span class="special">{</span><span class="command">\par</span>
  <span class="command">\setcounter</span><span class="special">{</span>section<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\setcounter</span><span class="special">{</span>subsection<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\gdef</span><span class="command">\thesection</span><span class="special">{</span><span class="command">\@</span>Alph<span class="command">\c</span>@section<span class="special">}</span><span class="special">}</span>
</pre></td></tr></table></figure>



<p>接下来，我们仿造它，定义一个新的命令 <code>\specialsectioning</code>。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">[</span>hyperref<span class="special">]</span><span class="special">{</span>ctexart<span class="special">}</span>
<span class="command">\newcommand</span><span class="command">\specialsectioning</span><span class="special">{</span><span class="command">\par</span>
  <span class="command">\setcounter</span><span class="special">{</span>section<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\setcounter</span><span class="special">{</span>subsection<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\renewcommand</span><span class="command">\thesection</span><span class="special">{</span><span class="command">\relax</span><span class="special">}</span><span class="special">}</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\tableofcontents</span>
<span class="command">\section</span><span class="special">{</span>正常编号的章节标题<span class="special">}</span>
<span class="command">\specialsectioning</span>
<span class="command">\section</span><span class="special">{</span>不编号的章节标题<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>编译之后我们会发现，在 <code>\specialsectioning</code> 之后的 <code>\section</code> 虽然不带星花，但已然不编号了，并且出现在了目录当中。</p>
<p>不过，正常标题的编号和标题正文之间是有一定的空距的。我们现在虽然将编号取消了，但是这个空距依然存在。虽然它不明显，但是毕竟是个问题。作为一个精益求精的完美主义者，我们要解决它。</p>
<p>正文中编号的格式由 LaTeX 内部宏 <code>\@seccntformat</code> 控制，默认是在编号后面加一个 <code>\quad</code>，我们把它去掉。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command">\def</span><span class="command">\@</span>seccntformat<span class="special">#</span><span class="special">#</span>1<span class="special">{</span><span class="command">\@</span>nameuse<span class="special">{</span>the<span class="special">#</span><span class="special">#</span>1<span class="special">}</span><span class="special">}</span>
</pre></td></tr></table></figure>



<p>此外，目录中的编号和章节标题之间也有距离，我们通过 <code>tocloft</code> 宏包来将这个距离设置为 <code>0pt</code>。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command">\addtocontents</span><span class="special">{</span>toc<span class="special">}</span><span class="special">{</span><span class="command">\def</span><span class="command">\cftsecnumwidth</span><span class="special">{</span>0pt<span class="special">}</span><span class="special">}</span>
</pre></td></tr></table></figure>



<p>这样，完整的代码变成：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>ctexart<span class="special">}</span>
<span class="command">\usepackage</span><span class="special">{</span>tocloft<span class="special">}</span>
<span class="command">\makeatletter</span>
<span class="command">\newcommand</span><span class="command">\specialsectioning</span><span class="special">{</span><span class="command">\par</span>
  <span class="command">\setcounter</span><span class="special">{</span>section<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\setcounter</span><span class="special">{</span>subsection<span class="special">}</span><span class="special">{</span>0<span class="special">}</span><span class="comment">%</span>
  <span class="command">\renewcommand</span><span class="command">\thesection</span><span class="special">{</span><span class="command">\relax</span><span class="special">}</span><span class="comment">%</span>
  <span class="command">\def</span><span class="command">\@</span>seccntformat<span class="special">#</span><span class="special">#</span>1<span class="special">{</span><span class="command">\@</span>nameuse<span class="special">{</span>the<span class="special">#</span><span class="special">#</span>1<span class="special">}</span><span class="special">}</span><span class="comment">%</span>
  <span class="command">\addtocontents</span><span class="special">{</span>toc<span class="special">}</span><span class="special">{</span><span class="command">\def</span><span class="command">\cftsecnumwidth</span><span class="special">{</span>0pt<span class="special">}</span><span class="special">}</span><span class="special">}</span>
<span class="command">\makeatother</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\tableofcontents</span>
<span class="command">\section</span><span class="special">{</span>正常编号的章节标题<span class="special">}</span>
<span class="command">\specialsectioning</span>
<span class="command">\section</span><span class="special">{</span>不编号的章节标题<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<hr>
<p>问题解决了，不过思路二这样做未免麻烦。在这个思路下，会不会有更简单的方法呢？答案是肯定的。</p>
<p>在 LaTeX 标准文档类中，secnumdepth 这个计数器是用来控制章节编号深度的。在 article 中，这个计数器的值默认是 3，对应的章节命令是 \subsubsection。也就是说，默认情况下，article 将会对 \subsubsection 及其之上的所有章节标题进行编号，也就是 \part, \section, \subsection, \subsubsection。</p>
<p>LaTeX 标准文档类中，最大的标题是 \part。它在 book 和 report 类中的层级是「-1」，在 article 类中的层级是「0」。因此，我们只需要将计数器设置为 -2，之后章节命令都不会编号了，从而解决问题。</p>
<p>我们来看一下代码。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="command">\documentclass</span><span class="special">{</span>ctexart<span class="special">}</span>
<span class="command">\makeatletter</span>
<span class="command">\newcommand</span><span class="command">\specialsectioning</span><span class="special">{</span><span class="command">\setcounter</span><span class="special">{</span>secnumdepth<span class="special">}</span><span class="special">{</span>-2<span class="special">}</span><span class="special">}</span>
<span class="command">\makeatother</span>
<span class="command">\begin</span><span class="special">{</span>document<span class="special">}</span>
<span class="command">\tableofcontents</span>
<span class="command">\section</span><span class="special">{</span>正常编号的章节标题<span class="special">}</span>
<span class="command">\specialsectioning</span>
<span class="command">\section</span><span class="special">{</span>不编号的章节标题<span class="special">}</span>
<span class="command">\end</span><span class="special">{</span>document<span class="special">}</span>
</pre></td></tr></table></figure>



<p>怎么样？是不是简单多了？</p>
]]></content>
    <summary type="html"><![CDATA[<p>LaTeX 标准文档类提供了 <code>\section</code> 和 <code>\section*</code> 等两组命令，用于排版章节标题。其中不带星号的版本有章节编号，会列入目录，同时修改章节标记。带星号的版本只有章节标题格式而不编号，不列入目录，也不会修改章节标记。</p>
<p>有时，我们会希望将不编号的章节标题列入目录。这种情况使用 <code>\section</code> 或 <code>\section*</code> 都不大合适。本文将对这些问题做出分析，并给出解决方案。</p>
]]></summary>
    
      <category term="Section" scheme="http://liam0205.me/tags/Section/"/>
    
      <category term="Sectioning" scheme="http://liam0205.me/tags/Sectioning/"/>
    
      <category term="Numbering" scheme="http://liam0205.me/tags/Numbering/"/>
    
      <category term="Table of Contents" scheme="http://liam0205.me/tags/Table%20of%20Contents/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[将微信上的文章推送到 Kindle 上]]></title>
    <link href="http://liam0205.me/2015/03/23/push-articles-to-kindle-from-wechat/"/>
    <id>http://liam0205.me/2015/03/23/push-articles-to-kindle-from-wechat/</id>
    <published>2015-03-23T03:23:24.000Z</published>
    <updated>2015-03-23T04:57:11.000Z</updated>
    <content type="html"><![CDATA[<p>微信是近几年发展起来的社交网络。微信公众号和微信朋友圈的出现，让微信变成了一个优秀的信息发布和传播平台。有甄别能力的同好，往往能在微信上找到不少好的文章。但是，一来用手机查看文章伤眼，二来微信上的文章不变保存，三来用手机看文章需要网络支持。总之，是有诸多不便。</p>
<p>昨天思考到这个问题之后，我有做一些搜索，而后就有了欣喜的发现：可以将微信里的文章、好友发来的文字消息免费推送到 Kindle 设备上。</p>
<a id="more"></a>

<h2 id=" 原理 ">原理</h2>
<p>激活 Kindle 之后，亚马逊都会为每一台 Kindle 设备分配一个电邮地址。向这个电邮地址里发送包含电子书的邮件，就可以将电子书推送到 Kindle 上了。当然，如此的话，可能会造成垃圾信息泛滥。因为如果不加限制，任何人都能往用户的 Kindle 上推送文件，结果会是一团糟。基于这些考虑，在亚马逊官网的后台里，提供了「认可的电邮地址」的设置。亚马逊在收到邮件之后，会检查这个认可的电邮列表。只有来信电邮在列表当中，亚马逊才会将电子书推送到 Kindle 上。</p>
<p>简单来说，亚马逊将 Kindle 和一个特定的电邮地址关联在一起，通过可信邮箱往上述电邮地址发送邮件，就能把附件中的电子书推送到 Kindle 上。</p>
<p>有了这样的基础知识，就不难理解微信推送的原理了。</p>
<p>亚马逊官方在微信上设立了一个公众平台，平台的后端就是一个电子邮箱。我们将微信上的文章保存在公众平台里，后端邮箱就会把文章发送到 Kindle 邮箱中，最后再推送到 Kindle 设备上。</p>
<p><img src="/attachment/images/Kindle/wechat_flowchat.png" alt=" 推送流程图 "></p>
<p>明确原理之后，我们来进行设置。</p>
<h2 id=" 亚马逊官网 ">亚马逊官网</h2>
<p>这里以中国亚马逊为例，如果你的 Kindle 使用的是美国亚马逊账号，请登录美国亚马逊网站进行相应操作。</p>
<p>登录中亚之后，点击下面的链接，进入 Kindle 管理页面。</p>
<p><a href="https://www.amazon.cn/mn/dcw/myx.html" target="_blank">https://www.amazon.cn/mn/dcw/myx.html</a></p>
<p>进入「我的设备」一栏，找到你的 Kindle 设备对应的图标。页面下方会显示出该设备对应的 Kindle 邮箱，请记下来。</p>
<p><img src="/attachment/images/Kindle/amazon01.png" alt=" 记录 Kindle 邮箱地址 "></p>
<p>进入「设置」一栏，在页面底部，点击「添加认可的电子邮箱」，将 <code>kindle@eub-inc.com</code> 添加到列表当中。</p>
<p><img src="/attachment/images/Kindle/amazon02.png" alt=" 将 `kindle@eub-inc.com` 添加到认可的电子邮箱列表当中 "></p>
<h2 id=" 微信 ">微信</h2>
<p>首先我们要关注亚马逊的微信公众平台。搜索公众号 <code>cn_Kindle</code> 并关注「亚马逊 Kindle 服务号」。</p>
<p><img src="/attachment/images/Kindle/wechat01.jpg" alt=" 亚马逊 Kindle 服务号 "></p>
<p>接下来，进入服务号界面，向服务号发送消息 <code>绑定 + 你的 Kindle 邮箱地址</code>。比如 <code>绑定 +myemail@kindle.cn</code>。</p>
<p><img src="/attachment/images/Kindle/wechat02.jpg" alt=" 绑定 Kindle 邮箱地址 "></p>
<h2 id=" 实际使用看看 ">实际使用看看</h2>
<p>周筠老师今天分享了一篇文章，我们把它推送到 Kindle 上看看。</p>
<p>打开这篇文章后，点击右上角的 <code>···</code>，选择「亚马逊 Kindle 服务号」。</p>
<p><img src="/attachment/images/Kindle/wechat03.jpg" alt=" 一键推送到 Kindle"></p>
<p>将你的 Kindle 设备连上网络，过一会儿，就能收到推送了。</p>
<p><img src="/attachment/images/Kindle/kindle01.png" alt="Kindle 截图 "></p>
]]></content>
    <summary type="html"><![CDATA[<p>微信是近几年发展起来的社交网络。微信公众号和微信朋友圈的出现，让微信变成了一个优秀的信息发布和传播平台。有甄别能力的同好，往往能在微信上找到不少好的文章。但是，一来用手机查看文章伤眼，二来微信上的文章不变保存，三来用手机看文章需要网络支持。总之，是有诸多不便。</p>
<p>昨天思考到这个问题之后，我有做一些搜索，而后就有了欣喜的发现：可以将微信里的文章、好友发来的文字消息免费推送到 Kindle 设备上。</p>
]]></summary>
    
      <category term="WeChat" scheme="http://liam0205.me/tags/WeChat/"/>
    
      <category term="Kindle" scheme="http://liam0205.me/tags/Kindle/"/>
    
      <category term="IT" scheme="http://liam0205.me/categories/IT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么我乐于分享？]]></title>
    <link href="http://liam0205.me/2015/03/19/why-i-love-to-share/"/>
    <id>http://liam0205.me/2015/03/19/why-i-love-to-share/</id>
    <published>2015-03-19T11:39:39.000Z</published>
    <updated>2015-03-19T12:39:15.000Z</updated>
    <content type="html"><![CDATA[<p>今天在<a href="http://www.zhihu.com" target="_blank">知乎</a>上第一次尝试回答了<a href="http://www.zhihu.com/question/25520742/answer/42443974" target="_blank">一个感情类问题</a>，得到了<a href="http://www.zhihu.com/people/yeka" target="_blank">周筠老师</a>的赞同。虽说是感情类问题，但主要想提及的是关于分享和共同进步的问题。无奈这个话题相对提问来说有些偏，所以只能另开文章讨论。</p>
<a id="more"></a>

<p>媳妇儿是个文科生，偏偏和我这个理科生看对了眼。我喜欢文学，却不得要领。每次看见媳妇儿写的文章，都羡慕嫉妒并着抓耳挠腮。媳妇儿是典型的文科生，对现象和规律不如理科生那么敏感。正赶着媳妇儿要学开车，对离合器一无所知有些犯怵。走在张家界的澧水大桥上，我就给她从她接触过的几个简单的物理公式讲起，借着变速自行车的例子把离合器和变速箱的原理讲了一遍。我不知道媳妇儿有没有都听明白，但是我讲完扭头看着她，分明是一脸崇拜的花痴样（我已经做好了跪搓衣板的准备，笑）。</p>
<p>媳妇儿说，她前男友是学语言的。偏偏媳妇儿是一个上进的姑娘，那时见着男朋友懂这门语言，就想请教。然而他却怎么也不肯教，问起原因，说是「担心教会了之后就没有吸引力了」。于是媳妇儿就问我，为什么我愿意将我所知道的知识分享给她。我说，「我把这些东西教给你，帮你打开思路，那样每天就能看见一个更好的你了，而且我也有向你学习啊」。</p>
<p>其实，两个人学习的专业不同、从事的行业不同、经历的人生不同，这些不同必然造成思维方式和处事模式的差异。两个人互相从对方身上学习，互相进步，这样日子才会过得越来越好，关系也会越来越亲密。</p>
<p>后来回到住处，媳妇儿给我说「你知道嘛，爱情就是两个人互相促进共同进步，所以我和你在一起特别有安全感」。文科生就是文科生，不对，媳妇儿不愧是我媳妇儿，我对媳妇儿这句话深表赞同，而且我认为在工作上也是如此。</p>
<p>父亲在我小的时候，因为工作的关系，去过不少公司工厂。每次出差回来，父亲都会讲讲所见所闻。虽然大多数的故事我都记不得了，但是有一则故事我一直记到现在。</p>
<p>父亲说，那次去的化工厂的技术部副主任以前是个技术过硬的老师傅，靠着自己的技术一步步走到这个位置。但是，现在的主任比他年轻得多，而且是以前还在他手下干过活。其实按照老师傅的资历和技术，他早就可以得到提拔。只是老师傅当年掌握着关键技术，因为害怕被人取代，所以不真心实意地教徒弟。这样一来，很长时间里都没有人能代替老师傅的位置。因此虽然薪资加了不少，但是领导一直不怎么提拔他。他就只能看着自己曾经的手下一步步超越自己。</p>
<p>其实，一方面，总结和分享的过程对自己也是一种学习；另一方面，学习是相互的，在自己分享的过程中，也会从对方身上学到自己不具备的东西；再者，给对方机会也最终是给自己机会。所以，真正自信的人都不会害怕分享自己的知识和技能，他们的着眼点永远是共同进步，一起变得更好。</p>
<p>所以啊，在被请教的时候，以及，更多地在生活的细微末节上，都不要吝惜自己的知识不乐于分享，更不要自觉高人一等盛气凌人。我一直认为，成长不是变得势利，而是变得温柔，对全世界都温柔。乐于分享，乐于共同进步，就是一种温柔呢。</p>
]]></content>
    <summary type="html"><![CDATA[<p>今天在<a href="http://www.zhihu.com" target="_blank">知乎</a>上第一次尝试回答了<a href="http://www.zhihu.com/question/25520742/answer/42443974" target="_blank">一个感情类问题</a>，得到了<a href="http://www.zhihu.com/people/yeka" target="_blank">周筠老师</a>的赞同。虽说是感情类问题，但主要想提及的是关于分享和共同进步的问题。无奈这个话题相对提问来说有些偏，所以只能另开文章讨论。</p>
]]></summary>
    
      <category term="Share" scheme="http://liam0205.me/tags/Share/"/>
    
      <category term="Life" scheme="http://liam0205.me/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[微笑着离开]]></title>
    <link href="http://liam0205.me/2015/02/01/smile-to-leave/"/>
    <id>http://liam0205.me/2015/02/01/smile-to-leave/</id>
    <published>2015-02-01T04:07:45.000Z</published>
    <updated>2015-02-03T04:34:26.000Z</updated>
    <content type="html"><![CDATA[<p>于是我化作一颗树，长在你必经的路旁，在阳光下慎重地开满了花，朵朵都是我前世的期盼。<br>当你走进，请你细听，颤抖的叶是我等待的热情。<br>而当你终于无视走过，在你身后落了一地的，不是花瓣，而是我凋零的心。<br>——「一颗开花的树」·席慕蓉</p>
<a id="more"></a>

<p>这是一首席慕蓉先生的诗，我很喜欢。以前我给你读过，告诉你说，还好不是「凋零的心」。然后我将它改编，写在微博上。</p>
<p>我化作一棵树，长在你必经的路旁，在阳光下慎重地开满了花。<br>每当有人走过，花儿就挥手致意。<br>而当你走过，花儿就开始欢呼，开始雀跃；仿佛我的灵魂飞旋在上空，在盘旋，在跳舞。</p>
<p>然而如今，似乎终于到了凋零的时候。席慕蓉先生终究是先哲前辈，肆意地改编先生的诗，却最终落入先生的套。</p>
<p>二零一四年八月一日，这是我们分手的日子。今天猛然想起，掰着指头一算，居然已过半年。小时候妈妈总说，玩起来时间过得特别快，所以要特别注意管理好自己的时间。今次我第一次发现，除掉开心，原来痛苦的时候，时间也可以飞逝而过的。</p>
<p>我还记得，你刚去诺村的时候，我不在身边。我很担心，于是拜托他照顾你。我还记得，在一周年纪念的时候，他抢在第一个回复，祝我们幸福。然而如今却是你和他在一起了。</p>
<p>所以我因此而难过吗？不，并不是。那我难过吗？是的，当然有。</p>
<p>分手之后你告诉我，你在和他约会。我说我知道了。但是我没有说，我早就知道你挂掉电话，和他一起出去超市，然后在餐厅共进晚餐。<br>分手之后你告诉我，你并不是在我和他之间做选择。我说我知道了。但是我没有说，我早就知道你在他家过夜，彻夜不归。<br>其实从你们开始在一起之后的事情，我都知道，这是我一直都没有说。</p>
<p>诺村很小，其中的华人圈子更小。说是在约会而不承认「在一起了」，其实没有什么意义，只是自欺欺人对吧。</p>
<p>于是我很难过，你却质问我说「难道你不能接受，一个曾经爱过你的人，不再爱你了吗」。我说我可以。但是我没有说，我不能接受你的背叛、欺瞒以及在分手之后用这些冠冕堂皇的句子企图安慰我。</p>
<p>所以我应该恨吗？我想我可以的。异地很难，我做好了心理准备，也做到了我能做的一切，得到的却是这样的结果。我当然可以恨，谁也不能指责我。然而我却要对自己说，我不可以恨。恨你，会把过去的美好的回忆清零，也会把将来的美好抹杀。所以我不可以恨。</p>
<p>于是我开始撕裂自己。我开始在每个将醒未醒的脑海里自己扇自己的耳光，企图把你赶出这个梦境。我开始在心里用木板搭建起房子，将有你的记忆全数封印。我必须强迫自己，将我曾经珍惜的东西视作尘土，以此求得一点好过。</p>
<p>然而方向错了，注定寻不到终点。人的记忆和计算机的硬盘里的数据不一样，不是说删除就能删除的。不管如何撕裂自己，终究都还是那个我；也不管如何封闭，房子总有可以透视的洞口。强迫自己忘记，却保留着可供回忆的实体，希冀终究可以不要忘记，这本身就是一个悖论。因此我要的解药不是忘记，而是真正接受之后的坦然和若无其事。</p>
<p>于是我删掉了所有的照片，丢掉了所有的纪念。我希望不要再看见这些看到就痛苦的东西，而是在内心保留过去你带给我的美好，以及向往未来的美好。我希望不是忘记，而是坦然接受，各自祝福。就好像安怡推荐的歌中唱响的那样，离开你，却带着更完美的微笑。</p>
]]></content>
    <summary type="html"><![CDATA[<p>于是我化作一颗树，长在你必经的路旁，在阳光下慎重地开满了花，朵朵都是我前世的期盼。<br>当你走进，请你细听，颤抖的叶是我等待的热情。<br>而当你终于无视走过，在你身后落了一地的，不是花瓣，而是我凋零的心。<br>——「一颗开花的树」·席慕蓉</p>
]]></summary>
    
      <category term="Love" scheme="http://liam0205.me/tags/Love/"/>
    
      <category term="Smile" scheme="http://liam0205.me/tags/Smile/"/>
    
      <category term="Leave" scheme="http://liam0205.me/tags/Leave/"/>
    
      <category term="Life" scheme="http://liam0205.me/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 LaTeX 中进行文学编程]]></title>
    <link href="http://liam0205.me/2015/01/23/literate-programming-in-latex/"/>
    <id>http://liam0205.me/2015/01/23/literate-programming-in-latex/</id>
    <published>2015-01-23T07:48:35.000Z</published>
    <updated>2015-04-10T08:47:54.000Z</updated>
    <content type="html"><![CDATA[<p>文学编程是 TeX 的作者高德纳提出的编程方式，主张程序员在编写代码的过程中详细地记录自己的思维方式和内在逻辑。</p>
<p>这种编程方式注重编码的逻辑而将编码本身放在更次要的位置，因而不充分的设计在这种变成方式下无所遁形。文学编程的另一个优点是它产生的代码文档能帮助程序员在任意时候重新会想起当时编码的思路。</p>
<p>在 LaTeX 中，可以用 Doc 和 DocStrip 这两个工具来实现文学编程。</p>
<a id="more"></a>

<p>对于程序员来说，最重要的有三个部分：</p>
<ul>
<li>代码；</li>
<li>代码文档；</li>
<li>用户手册。</li>
</ul>
<p>使用 Doc 和 DocStrip 可以将这三个部分集中到一个 <code>.dtx</code> 文件当中。这篇文章将分三个部分讲述如何构建这样一个 <code>.dtx</code> 文件。</p>
<h2 id="-ins_ 文件 "><code>.ins</code> 文件</h2>
<p>INS 三个字母是「Install」的缩写，顾名思义，这个文件是和安装相关的。<code>.ins</code> 文件通常用来控制 TeX 从 <code>.dtx</code> 文件里释放宏包文件，它的结构最为简单，大概是这样的。</p>
<ol>
<li>作为注释的版权信息</li>
<li><strong>载入 <code>docstrip.tex</code></strong></li>
<li>写入 DocStrip 的控制命令</li>
<li>编写将写入生成文件的版权信息</li>
<li><strong>生成文件指令</strong></li>
<li>写入提示信息用以完成安装</li>
<li><strong>结束安装文件</strong></li>
</ol>
<p>这里粗体标记的是必不可少的部分，其他部分或多或少都可以省略。</p>
<p>我们逐步构建一个完整的 <code>.ins</code> 文件。</p>
<hr>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">%% Copyright (C) 2003--2015</span>
<span class="comment">%% CTEX.ORG and any individual authors listed elsewhere in this file.</span>
<span class="comment">%% --------------------------------------------------------------------------</span>
<span class="comment">%%</span>
<span class="comment">%% This work may be distributed and/or modified under the</span>
<span class="comment">%% conditions of the LaTeX Project Public License, either</span>
<span class="comment">%% version 1.3c of this license or (at your option) any later</span>
<span class="comment">%% version. This version of this license is in</span>
<span class="comment">%%    http://www.latex-project.org/lppl/lppl-1-3c.txt</span>
<span class="comment">%% and the latest version of this license is in</span>
<span class="comment">%%    http://www.latex-project.org/lppl.txt</span>
<span class="comment">%% and version 1.3 or later is part of all distributions of</span>
<span class="comment">%% LaTeX version 2005/12/01 or later.</span>
<span class="comment">%%</span>
<span class="comment">%% This work has the LPPL maintenance status `maintained'.</span>
<span class="comment">%%</span>
<span class="comment">%% The Current Maintainers of this work are Leo Liu, Qing Lee and Liam Huang.</span>
<span class="comment">%% --------------------------------------------------------------------------</span>
</pre></td></tr></table></figure>



<p>这是 <code>ctex</code> 宏包的版权声明信息。</p>
<ul>
<li>这里的每一行都以百分号开头，因此在声明版权的同时不会影响正常的编译流程。</li>
<li>版权声明部分，首先是声明版权的归属。</li>
<li>接下来，声明许可协议为 LPPL。大多数 TeX 相关的宏包或软件，都在 LPPL 协议下发布。</li>
</ul>
<hr>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command">\input</span> docstrip.tex
</pre></td></tr></table></figure>



<p>载入 <code>docstrip.tex</code>。</p>
<hr>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command">\keepsilent</span>
</pre></td></tr></table></figure>



<p>这是 DocStrip 的控制命令之一，其作用是关闭 DocStrip 的日志输出功能。默认情况下，DocStrip 会详细输出它的每一步操作。对于大多数人来说，成百上千行的日志徒惹人嫌弃，因此我们关闭它。</p>
<p>更多的控制命令可以参考 DocStrip 的文档。</p>
<hr>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="command">\preamble</span>

    Copyright (C) 2003-2015
    CTEX.ORG and any individual authors listed in the documentation.
------------------------------------------------------------------------------

    This work may be distributed and/or modified under the
    conditions of the LaTeX Project Public License, either
    version 1.3c of this license or (at your option) any later
    version. This version of this license is in
       http://www.latex-project.org/lppl/lppl-1-3c.txt
    and the latest version of this license is in
       http://www.latex-project.org/lppl.txt
    and version 1.3 or later is part of all distributions of
    LaTeX version 2005/12/01 or later.

    This work has the LPPL maintenance status `maintained'.

    The Current Maintainers of this work are Leo Liu, Qing Lee and Liam Huang.
------------------------------------------------------------------------------

<span class="command">\endpreamble</span>
</pre></td></tr></table></figure>



<p>在 <code>\preamble</code> 和 <code>\endpreamble</code> 之间的部分，将被写入由 DocStrip 生成的所有文档（默认情况下）。比如上面这段 <code>ctex</code> 宏包的版权信息将写入每一个生成的文件。</p>
<hr>
<p>下面的内容是整个 <code>.ins</code> 文件里最重要的部分，它控制着如何生成最终的宏包文件。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="command">\generate</span>
  <span class="special">{</span>
    <span class="command">\usedir</span><span class="special">{</span>tex/latex/ctex<span class="special">}</span>
    <span class="command">\file</span><span class="special">{</span>ctex.sty<span class="special">}</span>                 <span class="special">{</span><span class="command">\from</span><span class="special">{</span><span class="command">\jobname</span>.dtx<span class="special">}</span><span class="special">{</span>package,style<span class="special">}</span><span class="special">}</span>
    <span class="command">\file</span><span class="special">{</span>ctexcap.sty<span class="special">}</span>              <span class="special">{</span><span class="command">\from</span><span class="special">{</span><span class="command">\jobname</span>.dtx<span class="special">}</span><span class="special">{</span>package,ctexcap<span class="special">}</span><span class="special">}</span>
    <span class="command">\file</span><span class="special">{</span>ctexsize.sty<span class="special">}</span>             <span class="special">{</span><span class="command">\from</span><span class="special">{</span><span class="command">\jobname</span>.dtx<span class="special">}</span><span class="special">{</span>package,ctexsize<span class="special">}</span><span class="special">}</span>
    <span class="command">\file</span><span class="special">{</span>ctexart.cls<span class="special">}</span>              <span class="special">{</span><span class="command">\from</span><span class="special">{</span><span class="command">\jobname</span>.dtx<span class="special">}</span><span class="special">{</span>class,article<span class="special">}</span><span class="special">}</span>
    <span class="command">\file</span><span class="special">{</span>ctexbook.cls<span class="special">}</span>             <span class="special">{</span><span class="command">\from</span><span class="special">{</span><span class="command">\jobname</span>.dtx<span class="special">}</span><span class="special">{</span>class,book<span class="special">}</span><span class="special">}</span>
    <span class="command">\file</span><span class="special">{</span>ctexrep.cls<span class="special">}</span>              <span class="special">{</span><span class="command">\from</span><span class="special">{</span><span class="command">\jobname</span>.dtx<span class="special">}</span><span class="special">{</span>class,report<span class="special">}</span><span class="special">}</span>
    <span class="command">\file</span><span class="special">{</span>ctexspa.def<span class="special">}</span>
      <span class="special">{</span>
        <span class="command">\from</span><span class="special">{</span><span class="command">\jobname</span>.dtx<span class="special">}</span>         <span class="special">{</span>ctexspa<span class="special">}</span>
        <span class="command">\from</span><span class="special">{</span>ctexpunct.spa<span class="special">}</span>        <span class="special">{</span><span class="special">}</span>
      <span class="special">}</span>
  <span class="special">}</span>
</pre></td></tr></table></figure>



<p><code>\generate</code> 命令中的<code>\file{⟨filename⟩}{\from{⟨sourcefilename⟩}{⟨optionlist⟩}}</code> 用来指定宏包文件的生成方式。这里的含义是，从 <code>⟨sourcefilename⟩</code> 中抽取含有 <code>⟨optionlist⟩</code> 标记的部分，生成 <code>⟨filename⟩</code> 这个文件。</p>
<p>一个 <code>\generate</code> 里可以有多个 <code>\file</code> 命令。一个 <code>\file</code> 命令里可以有多个 <code>\from</code> 命令。一个 <code>\from</code> 命令里的 <code>⟨option⟩</code>，组成 <code>⟨optionlist⟩</code>。其中 <code>⟨option⟩</code> 需要用逗号隔开，<code>\file</code> 之间和 <code>\from</code> 之间则不需要。</p>
<hr>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="command">\obeyspaces</span>
<span class="command">\Msg</span><span class="special">{</span>*************************************************************<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*                                                           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>* To finish the installation you have to move the following *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>* file into proper directories searched by TeX:             *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*                                                           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>* The recommended directory is TDS:tex/latex/ctex           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*                                                           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*     ctex.sty                                              *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*     ctexcap.sty                                           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*     ctexsize.sty                                          *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*     ctexart.cls                                           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*     ctexbook.cls                                          *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*     ctexrep.cls                                           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*     ctexspa.def                                           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*                                                           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>* To produce the documentation run the file ctex.dtx        *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>* through XeLaTeX.                                          *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*                                                           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>* Happy TeXing!                                             *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*                                                           *<span class="special">}</span>
<span class="command">\Msg</span><span class="special">{</span>*************************************************************<span class="special">}</span>
</pre></td></tr></table></figure>



<p>这里的内容会在处理完 <code>.ins</code> 文件之后显示在控制台，用来提示使用者将文件置入指定的目录。TeX 会忽略连续的空格，第一行的 <code>\obeyspaces</code> 则会让 TeX 输出这些空格。</p>
<hr>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command">\endbatchfile</span>
</pre></td></tr></table></figure>



<p>显式地结束安装文件，此后的所有内容都会被忽略。</p>
<p>将上面的代码依次粘贴到一起，就是一个最简单的 <code>.ins</code> 文件了。</p>
<h2 id="-dtx_ 文件 "><code>.dtx</code> 文件</h2>
<p><code>.dtx</code> 文件比 <code>.ins</code> 文件复杂得多。<code>.ins</code> 文件在整个过程中会被读取一次，而 <code>.dtx</code> 文件却会被读取三次。下面是对此三个步骤的简略描述。如果暂时看不懂也没有关系，下一节我们将会化身人肉编译器，逐行分析示例。</p>
<p>处理 <code>.ins</code> 文件的时候，会载入 <code>.dtx</code> 文件。这时候 <code>.dtx</code> 文件中以 <code>%</code> 开头的行将被全部忽略，而以 <code>%</code> 开头的行则会用于记录 <code>⟨option⟩</code>。程序会根据 <code>.ins</code> 文件中 <code>\generate</code> 命令里 <code>\from</code> 的指示的 <code>⟨option⟩</code> 抽取 <code>.dtx</code> 文件中 <code>⟨option⟩</code> 相关内容。这个过程中，没有以 <code>%</code> 开头的行会根据 <code>⟨option⟩</code> 写入文件，而 <code>%</code> 开头的行则被抑制并保护起来。最终生成宏包文件。</p>
<p>第二遍处理 <code>.dtx</code> 文件的时候，在读入 <code>\documentclass{ltxdoc}</code> 之前，所有的内容与通常意义上的 LaTeX 代码完全一致。因此需要依靠 <code>\iffalse</code> 和 <code>% \iffalse</code> 来保护相关代码，这些代码通常是 README 文件和 LICENSE 文件。在读入 <code>\DocInput{filename.dtx}</code> 之后，<code>.dtx</code> 文件会被第三次载入处理。处理完成之后遇到 <code>\end{document}</code>，后续的内容被全部忽略。最终生成说明文档。</p>
<p>第三遍处理 <code>.dtx</code> 是被 <code>\DocInput</code> 载入的。此时，文档内（几乎）所有的 <code>%</code> 都被忽略。因为 LaTeX 只能有一个 <code>\documentclass</code> 以及一对 <code>\begin{document}</code> 和 <code>\end{document}</code>，所以 <code>\end{document}</code> 之前的所有内容都应当在这一次处理的时候被忽略。因此这部分内容应该被 <code>\iffalse</code> 和 <code>\fi</code> 保护起来。</p>
<p><code>.dtx</code> 文件由以下部分组成。</p>
<ol>
<li>包含在 <code>% \iffalse</code> 和 <code>% \fi</code> 中间的版权信息</li>
<li><strong>包含在 <code>% \iffalse</code> 和 <code>% \fi</code> 中间的宏包基本信息</strong></li>
<li><strong>包含在 <code>%&lt;*driver&gt;</code> 和 <code>%&lt;/driver&gt;</code> 中间的 <code>ltxdoc</code> 文档类及相关代码，这部分代码也应包含在 <code>% \iffalse</code> 和 <code>% \fi</code> 中间</strong></li>
<li><strong>在 <code>\end{document}</code> 之后的说明文档，这部分文档应该隐藏在行首的 <code>%</code> 之后</strong></li>
<li><strong>在说明文档最后的代码说明，以及间杂在代码说明中间的代码，其中代码说明也应该隐藏在行首的 <code>%</code> 之后，而代码本身则不应该被 <code>%</code> 保护</strong></li>
</ol>
<p>示例 <code>.dtx</code> 文件的具体内容，可以参看下一节。</p>
<h2 id=" 人肉编译器 ">人肉编译器</h2>
<p>我们来看两个文件，分别是 <a href="/attachment/LaTeX-useful-tools/dtxtut/dtxtut.ins"><code>dtxtut.ins</code></a> 和 <a href="/attachment/LaTeX-useful-tools/dtxtut/dtxtut.dtx"><code>dtxtut.dtx</code></a>。你可以下载这两个文件，然后跟着我的思路一起分析。</p>
<p>首先我们要生成宏包文件，在命令行中运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>xelatex dtxtut.ins
</pre></td></tr></table></figure>



<p>注意，这里的后缀名不可省略。</p>
<p>文件读入之后，直到 12 行都是注释，直接忽略。接着到了第 13 行，读入了 <code>docstrip.tex</code> 这个文件。随后进行了一些设置之后来到了第 26 行.</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="command">\generate</span><span class="special">{</span><span class="command">\file</span><span class="special">{</span><span class="command">\jobname</span>.sty<span class="special">}</span><span class="special">{</span><span class="command">\from</span><span class="special">{</span><span class="command">\jobname</span>.dtx<span class="special">}</span><span class="special">{</span>package<span class="special">}</span><span class="special">}</span><span class="special">}</span>
</pre></td></tr></table></figure>



<p>这里 <code>\jobname</code> 是当前文件的名字（不含后缀），即 <code>dtxtut</code>。所以这里会从 <code>dtxtut.dtx</code> 文件中，抽取 <code>package</code> 的部分，组成名为 <code>dtxtut.sty</code> 这个文件。</p>
<p>现在我们读取 <code>dtxtut.dtx</code>。前 18 行都是注释，忽略。19 — 21 行是 <code>package</code> 部分，输出。23 行开始了名为 <code>driver</code> 的部分，直到 32 行结束。接下来一直到 81 行都是注释，忽略。82 行开始了名为 <code>package</code> 的部分，于是程序将 82 行开始到 100 行中没有注释掉的部分抽出来，输出。这样，输出的内容接在 <code>\preamble</code> 之后，保存为 <code>dtxtut.sty</code> 文件。</p>
<p>接下来我们生成宏包文档，在命令行中运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>xelatex dtxtut.dtx
</pre></td></tr></table></figure>



<p>同样，这里的后缀名不可省略。</p>
<p>前 23 行都是注释，忽略。24 行载入了 <code>ltxdoc</code> 文档类，随后载入了刚刚生成的 <code>dtxtut.sty</code> 宏包。26 行的 <code>\EnableCrossrefs</code> 打开了代码索引的生成（如果你将来不需要，可以用 <code>\DisableCrossrefs</code> 打开）。27 行的 <code>\CodelineIndex</code> 则使得索引指向代码行号，而不是页码。28 行的 <code>\RecordChanges</code> 则会让文档类记录宏包的变化记录。</p>
<p>接下来，30 行的 <code>\DocInput{\jobname.dtx}</code> 重新载入了这个文件本身，但（几乎）所有的 <code>%</code> 符号都被忽略。第 1 行遇到 <code>\iffalse</code>，直到 16 行的 <code>\fi</code>，中间的内容都被忽略。17 行是空行。18 行又遇到 <code>\iffalse</code>，直到 33 行的 <code>\fi</code>，中间的内容都被忽略。注意，这里正好跳过了 <code>driver</code> 部分。</p>
<p>接下来的 <code>\CheckSum</code> 和 <code>\CharacterTable</code> 是为了检测 <code>.dtx</code> 文件完整性的两个工具。众所周知，<code>.dtx</code> 文件包含了一个宏包的几乎所有信息，如果文件在网络传输的过程中出错，则宏包安装必然失败。因此，检测文件的完整性就变得很有必要。</p>
<p><code>\CheckSum</code> 采用了一个很简单的方案来检验完整性。它将从 <code>\StopEventually</code> 开始到 <code>\Finale</code> 结尾的，在 <code>macrocode</code> 环境里的反斜杠 <code>\</code> 计数，将计数的值作为校验和。在生成文档的过程中，程序将会计算这个值，并于 <code>\CheckSum{}</code> 中的值进行比对。若二者不一致，则说明传输过程中可能出现错误。</p>
<p><code>\CharacterTable</code> 更为直接一点。程序将检查代码中出现的符号均包含在 <code>\CharacterTable</code> 之中。若不然，则认为传输过程中可能出错。</p>
<p>接下来的内容，直到第 76 行都很好理解。77 行出现了 <code>\StopEventually</code> 命令，并在参数中启动了 <code>\PrintIndex</code> 命令。我们刚才说了 <code>\StopEventually</code> 会开启校验和的检查，而 <code>\PrintIndex</code> 则会在此处打印代码索引。</p>
<p><code>macrocode</code> 环境是一个特殊的环境，它有点类似于 LaTeX 原生的 <code>verbatim</code> 环境。它在大多数情况下的行为和 <code>verbatim</code> 环境相同，大体上是将代码输出到最终的文档当中。</p>
<p>这样持续运行到 103 行，遇到 <code>\Finale</code> 命令，校验和计算的终点。此时，程序将会计算出校验和，并与文档中给出的校验和进行比较。如果 <code>\CheckSum</code> 不存在，或者给出的值为 <code>0</code>，那么程序会给出正确的值，让你填入文档。如果 <code>\CheckSum</code> 存在，但值与程序计算的不符，那么程序会报错，并给出正确的值。改正后重新编译才能得到文档。如果 <code>\CheckSum</code> 存在，且校验和通过，那么程序会继续运行。</p>
<p>104 行是 <code>\endinput</code>，结束整个文件，本次对 <code>dtxtut.dtx</code> 的处理结束，回到上一次的断点。</p>
<p>30 行之后，31 行就是 <code>\end{document}</code>，文档处理结束，之后的内容全都被忽略。输出文档，退出。</p>
<h2 id=" 将 _-dtx_ 和 _-ins_ 合二为一 ">将 <code>.dtx</code> 和 <code>.ins</code> 合二为一</h2>
<p>细心的读者会发现，整个过程中，<code>.dtx</code> 文件承担了几乎所有的功能，而 <code>.ins</code> 文件只是一个「指路人」。这些读者可能会思考，是不是有办法将 <code>.ins</code> 文件并入 <code>.dtx</code> 文件呢？答案是肯定的。</p>
<p>对于这类合二为一的 <code>.dtx</code> 文件，使用 Plain TeX 格式编译，会启动 DocStrip 工具，得到宏包文件；使用 LaTeX 格式编译，则会生成文档。</p>
<p>这里给出一个来自<a href="http://www.zhihu.com/question/27693438" target="_blank">知乎提问</a>的<a href="/attachment/LaTeX-useful-tools/dtxtut/insdtxtut.dtx">示例</a>（略有修改），你可以在<a href="http://www.zhihu.com/question/27693438/answer/37669407" target="_blank">我的答案</a>里看到对此的具体分析。</p>
<h2 id=" 最后的最后 ">最后的最后</h2>
<p>今天是 W 的生日。祝你生日快乐~</p>
]]></content>
    <summary type="html"><![CDATA[<p>文学编程是 TeX 的作者高德纳提出的编程方式，主张程序员在编写代码的过程中详细地记录自己的思维方式和内在逻辑。</p>
<p>这种编程方式注重编码的逻辑而将编码本身放在更次要的位置，因而不充分的设计在这种变成方式下无所遁形。文学编程的另一个优点是它产生的代码文档能帮助程序员在任意时候重新会想起当时编码的思路。</p>
<p>在 LaTeX 中，可以用 Doc 和 DocStrip 这两个工具来实现文学编程。</p>
]]></summary>
    
      <category term="Literate Programming" scheme="http://liam0205.me/tags/Literate%20Programming/"/>
    
      <category term="dtx" scheme="http://liam0205.me/tags/dtx/"/>
    
      <category term="Macro" scheme="http://liam0205.me/tags/Macro/"/>
    
      <category term="LaTeX" scheme="http://liam0205.me/categories/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[欧洲史·三：浪漫主义与古希腊哲学]]></title>
    <link href="http://liam0205.me/2015/01/22/history-of-europ-03/"/>
    <id>http://liam0205.me/2015/01/22/history-of-europ-03/</id>
    <published>2015-01-22T08:09:38.000Z</published>
    <updated>2015-01-22T16:13:57.000Z</updated>
    <content type="html"><![CDATA[<p>前两篇文章（<a href="/2014/12/30/history-of-europe-01/">第一篇</a>、<a href="/2015/01/06/history-of-europe-02/">第二篇</a>）讨论了欧洲文明发源的三股力量，以及欧洲思想发源的几次思想运动。今次，我们将暂别对理性的讨论，转而讨论与理性相对的浪漫主义；同时我们也会一睹古希腊三大哲人的风采。</p>
<a id="more"></a>

<h2 id=" 浪漫主义 ">浪漫主义</h2>
<h3 id=" 浪漫主义运动从德国发端 ">浪漫主义运动从德国发端</h3>
<p>我们前面说到，欧洲这个混合体由希腊罗马、教会和日耳曼民族组成。前面说到的浪漫主义运动、宗教改革、科学革命还有启蒙运动主要都是前两个部分相互作用的结果。今次要谈的浪漫主义运动则发短语继承自日耳曼民族的德意志民族。（公元 919 年之后建国的国家中的人民称德意志，之前称日耳曼）</p>
<p>18 世纪末，法国爆发了大革命，传统的君主制阶层观念、贵族以及天主教会统治制度在三年内被推翻；新的自由、平等、博爱等原则被建立起来。尽管人们对理性的期望很高，但是法国大革命废除了君主和教会之后，并没有迎来民智开启的时代，反而因为激进的思想，迎来了流血、暴政和独裁。</p>
<p>针对法国启蒙运动的观点，发端于德意志的浪漫主义运动崇尚感受、情绪和强烈的情感。德国人认为理性但抽象的词语不能用来描绘人类和社会，这完全是空谈；他们相信自己的历史和文化根治于自己体内，因此与法国人是不同的，所以法国人在沙龙里谈论的普世理性是不存在的；他们希望知道早期日耳曼民族在进入结合体之前是什么状态，喜欢他们的活力和补拙。</p>
<p>浪漫主义认为<strong>文明是人为的，因此文明会束缚和局限我们。因此，超脱这些束缚，活在传统文化当中，才算是活得完整。</strong>至此，知识分子才开始尊重并对文化开始有兴趣，开始收集民俗文化和乡村歌谣。并且从此，这些观念深植于欧洲人的思想之中。</p>
<h3 id=" 民主主义源自浪漫主义 ">民主主义源自浪漫主义</h3>
<p>浪漫主义对自己民族历史和文化的尊重被扩大强化之后，就形成了民族主义。民族主义者认为拥有相同历史、文化和语言的人们组成的民族应当生活在一起，并组建自己的政府。民族主义者认为，多民族的国家里，任何一个民族都无法充分表达自己的观点，无法充分伸张自己的文化，因此任何民族的智慧都无法开花结果。</p>
<h3 id=" 教会的结局 ">教会的结局</h3>
<p>中世纪结束之后，文艺复兴、宗教改革、科学革命、启蒙运动以及浪漫主义运动分别在不同的角度削弱了教会的权威。事实上，现代理性、科学和进步的思想从文艺复兴、科学革命和启蒙运动一脉相承自古希腊；而现在对文化、解放思想的崇尚则从浪漫主义运动继承自日耳曼民族。反观教会，留下的则是一片空白。</p>
<h2 id=" 理性和浪漫的撕扯 ">理性和浪漫的撕扯</h2>
<p>理性和浪漫是两股根植在欧洲人心中的截然相反的力量。这两股力量往往对立，互相撕扯。</p>
<p>我们先来看一个例子。如果在学校里给学生讲述下面这段故事，并将之奉为真理，你会怎么看待？这个故事来自旧约圣经的第一篇：创世纪。</p>
<blockquote>
<p>耶和华上帝用地上的尘土造人，将生气吹在他鼻孔里，他就成了有灵的活人，名叫亚当。</p>
</blockquote>
<p>如果你的孩子是这个学校里的一个学生，你会怎么想呢？作为一个现代社会的文明人，你一定会反对学校这样的做法，你会认为学校在胡说八道误人子弟。</p>
<p>那么反过来，再看另外一个故事。这个故事是澳大利亚土著人的一个传说。</p>
<blockquote>
<p>很久很久以前，有个老人非常疼爱他的侄儿。年轻的侄儿远赴异国，爱上了一个年轻女孩儿。这对情侣后来不顾长辈的反对，私奔出走。但女孩儿已被许配给另外一个人，所以女孩儿的部落派人追到他们，杀死了他的侄儿。老人听到噩耗非常伤心，不顾年老体弱，跋涉到这个国家，打算将侄儿的尸体带回故土。</p>
<p>侄儿已经成年，然而老人年事已高。将侄儿的尸体从异国运回故土，对于老人来说是个沉重的负担。但是老人办到了，它将尸体带回，妥善安葬。至今你仍然能够看到老人跋涉的足迹，仍然能看到他中途休息的地方，仍然能看到他的泪水汇成的水潭。</p>
</blockquote>
<p>同样的假设，你会怎么想呢？尽管你知道这个故事浪漫主义色彩浓厚，肯定不是真实的，但是你可能仍然会希望学校将这个「美好」的故事讲给学生们听。</p>
<p>两个故事都有明显不真实的地方，但是我们对它们的态度却截然不同。面对第一个故事的时候，理性占了上风；而面对第二个故事的时候，浪漫主义的情怀却占了上风。</p>
<p>若然生活在启蒙时代，可能会有人对你说：「如果你的孩子想知道水潭的来源，那你可以送他去学地质学」。可能还有人会对你说：「这些土著人的思想已经被黑暗和魔法带来的恐惧束缚住了，你不要相信这些」。这感觉很别扭不是吗？对于我们来说，我们往往会迷失在浪漫主义的情怀之中，潜意识地认为土著人的生活方式更加纯粹、健全和自然，不由自主地希望这些「信仰」传承下去。</p>
<p>这样的撕扯就是理性和浪漫对立的一面。这样的撕扯源自于启蒙运动和浪漫主义运动的冲突，而追根究底的原因是欧洲文明那个奇怪的混合体的矛盾。这样的撕扯不断困扰和瓦解着欧洲的道德观念和智识生活，并成为欧洲人的「宿命」之一。</p>
<h2 id=" 古希腊三大哲人的风采 ">古希腊三大哲人的风采</h2>
<p>让我们「重归」理性。</p>
<p>前文已经提到，文艺复兴时期的人们认为「古典就是最好的」。这样的观点在 17 世纪才因古希腊人的宇宙观（地心说）被打破而逐渐缓解。自那时起，人们慢慢将目光从古希腊已有的成就上转移开来，开始关注现代人可能达成的成就。</p>
<p>不过，尽管如此，在一些领域里我们的成就依然坐落在希腊人打下的基石上。而对后世影响甚深的人就是古希腊的三大哲人：苏格拉底、柏拉图和亚里士多德。</p>
<h3 id=" 苏格拉底 ">苏格拉底</h3>
<p>苏格拉底是一个，呃……，对思辨的向往近乎疯魔的人。他作为古希腊最伟大的哲人之一，并没有给出真理，但是去做了更伟大的事：给出了迈向真理的方法。</p>
<p>苏格拉底认为真理切实存在，但平常人的心智并不足以理解真理。因此，渴望得到真理的人必须耕耘其心智。而这种方法其实就是「有理有据地怀疑一切」。</p>
<p>苏格拉底问答法是类似于这样的对话：</p>
<blockquote>
<p>老师：什么是革命？</p>
<p>学生：用武力推翻政府就是革命。</p>
<p>老师：如果国王的弟弟弑君篡位，那么这样以武力推翻的行为是革命吗？</p>
<p>学生：不是。</p>
<p>老师：那除了武力推翻之外，还需要怎样的条件才能算是革命呢？</p>
</blockquote>
<p>苏格拉底问答法实际是在不断地举出反例的过程中，修正已有的观点。这样的方法能不断剔除谬误的部分，使得结论逐渐趋向真理。</p>
<h3 id=" 柏拉图 ">柏拉图</h3>
<p>柏拉图是苏格拉底的弟子。如今有关苏格拉底的实际，一部分就是出自柏拉图之手。苏格拉底「怀疑一切」的主张影响了雅典的统治者，因此被最终处死。在柏拉图的描述中，苏格拉底平静地面对死亡，对无法思辨的苟且无法容忍，从容地结束了自己的生命。</p>
<p>然而，如若换过一个角度，人们对苏格拉底的崇敬可能就会大打折扣。比如，如果公诉苏格拉底的检察官之子因为听信苏格拉底的言论，怀疑一切，最终成为一个不务正业的酒鬼；然后检察官认为苏格拉底是妖言惑众，应当处死。</p>
<p>这样的思辨，其实正是苏格拉底崇尚的「怀疑一切」。而对一切事物都充满怀疑，会让我们迷失方向；我们不可能靠纯粹的理性生活、工作并组成社会，我们在理性的同时，也需要有风俗、习惯甚至是宗教来指引方向。</p>
<p>柏拉图认为，<strong>我们在世间的所思所想，其实只是另一个崇高世界里的影子</strong>。因此，单纯地依靠思辨，单纯地怀疑一切，并不能求得真理。柏拉图为了说明他的观点，举了一个例子。</p>
<blockquote>
<p>假设有一群人，被关在暗无天日的深邃山洞。山洞只有一个洞口，被铁门锁死。洞口的外面是长长的走廊，走廊的尽头有一只火把。</p>
<p>火把摇曳的火光将经过的人和动物投影在山洞里的墙壁上，于是这些人在山洞里为看到的影子评头论足，进行推理辩论，相信这就是这个世界上真实的存在。</p>
</blockquote>
<p>这其实就是中国「坐进观天」故事的翻版，很可笑不是吗？<strong>当你身锁牢笼却不自知，目光局限在其中，光靠思辨是不可能获得真理的</strong>。</p>
<h3 id=" 亚里士多德 ">亚里士多德</h3>
<p>亚里士多德是柏拉图的学生，没错他是苏格拉底的徒孙。亚里士多德在许多方面都有重大贡献，他总结整理了很多已有的知识，并根据自己的观察得出了很多精彩的结论。诚然，受于条件所限（身处某个牢笼），他的结论在如今看来并不完全正确（比如地心说）；但是，亚里士多德对与清晰思考的理论却依然闪耀。这就是「亚里士多德三段论」。</p>
<p>亚里士多德的三段论将论述分为三个部分，前两个部分是前提，第三个部分是结论。第一个部分是抽象的概述；第二个部分是对具体实例的描述；第三个部分则针对实例做出推论。<strong>如果前提正确，并且推论过程符合逻辑，那么结论就必然是正确的</strong>。</p>
<p>比如：</p>
<blockquote>
<p>每一只正常的猫都有四条腿。</p>
<p>Kitty 是一只正常的猫。</p>
<p>Kitty 有四条腿。</p>
</blockquote>
<p>这就是一个成立的结论。首先，前两个前提是正确的；其次，两个前提之间有「连续的主宾判断逻辑」；因此，结论成立。</p>
<p>再比如：</p>
<blockquote>
<p>每一只正常的猫都有四条腿。</p>
<p>Kitty 有四条腿。</p>
<p>Kitty 是一只正常的猫。</p>
</blockquote>
<p>这是一个不成立的结论。尽管两个前提是正确的，但是两个前提之间并没有连续的逻辑，因此结论是站不住脚的。比如，Kitty 可能是一只兔子，或是一只狗。</p>
<p>再比如：</p>
<blockquote>
<p>每一只猫都是黑色的。</p>
<p>Kitty 是一只猫。</p>
<p>Kitty 是黑色的。</p>
</blockquote>
<p>这也是一个不成立的结论。尽管两个前提之间有连续的逻辑，但是第一个前提是错误的，因此结论也是站不住脚的。</p>
<p>尽管举出的例子很简单，但是却反映了亚里士多德三段论的威力。三段论的意义在于</p>
<ul>
<li>它给出了推理的一般规则：严谨遵循这个规则就能求得真理；</li>
<li>它给出了检验推论的标准：从前提的正确性和推理的逻辑性两方面检查推论，若然有一方面错误，则结论不成立。</li>
</ul>
<h2 id=" 小结 ">小结</h2>
<p>欧洲的文明发端于古代希腊和罗马与教会和日耳曼民族混合成为的一个不稳定的混合体。这个混合体随着文艺复兴运动而逐渐瓦解，经历宗教改革、科学革命、启蒙运动和浪漫主义运动，宗教的力量被削弱，逐渐形成我们如今看到的欧洲。</p>
<p>理性和浪漫的力量彼此对立，互相撕扯。这份根植在欧洲人文化血脉里的矛盾，煎熬着欧洲人的同时，也成为欧洲不断进步的动力。</p>
<p>尽管在科学革命之后，人们已不再将古希腊的学术奉为圭臬，但实际上是人们重新走在了由希腊人奠基的理性思辨道路上。苏格拉底为人们展现了通往真理的道路；他的弟子柏拉图用经典的比喻警醒人们不能坐进观天；柏拉图的弟子亚里士多德则在前辈的基础上整理了很多知识，并总结出了威力强大的「三段论」。</p>
<p>真想去欧洲看看呀~ : )</p>
]]></content>
    <summary type="html"><![CDATA[<p>前两篇文章（<a href="/2014/12/30/history-of-europe-01/">第一篇</a>、<a href="/2015/01/06/history-of-europe-02/">第二篇</a>）讨论了欧洲文明发源的三股力量，以及欧洲思想发源的几次思想运动。今次，我们将暂别对理性的讨论，转而讨论与理性相对的浪漫主义；同时我们也会一睹古希腊三大哲人的风采。</p>
]]></summary>
    
      <category term="History" scheme="http://liam0205.me/tags/History/"/>
    
      <category term="Europe" scheme="http://liam0205.me/tags/Europe/"/>
    
      <category term="Romantic" scheme="http://liam0205.me/tags/Romantic/"/>
    
      <category term="Greece" scheme="http://liam0205.me/tags/Greece/"/>
    
      <category term="Philosophy" scheme="http://liam0205.me/tags/Philosophy/"/>
    
      <category term="Literature and Social Sciences" scheme="http://liam0205.me/categories/Literature%20and%20Social%20Sciences/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[欧洲史·二：欧洲的思潮]]></title>
    <link href="http://liam0205.me/2015/01/06/history-of-europe-02/"/>
    <id>http://liam0205.me/2015/01/06/history-of-europe-02/</id>
    <published>2015-01-06T13:27:37.000Z</published>
    <updated>2015-01-22T08:20:23.000Z</updated>
    <content type="html"><![CDATA[<p><a href="/2014/12/30/history-of-europe-01/">上一次</a>讲到欧洲文明发端的三股力量和古典、中世纪和近代在事件和时间上的划分。今次写一写和思想有关的东西。</p>
<p>上述三股力量组成的混合体经历了长达一千年的中世纪时期。然而，尽管持续时间很长，这个混合体内部却并不稳定。伴随着文艺复兴的开始，从公元 1400 年左右开始，这个混合体逐渐崩毁，并开始建立起新的秩序。</p>
<a id="more"></a>


<h2 id=" 文艺复兴 ">文艺复兴</h2>
<p>前一篇文章里提到，中世纪时期，基督教会保留了许许多多的古希腊科学文化知识。然而，基督教会却没有将这些科学文化知识公开；而是藏起来，选择其中对维护自己教义有利的知识，甚至是曲解其中的含义来维护自己的教义。这实际上是对人的思想的一种控制。基督教会利用这些知识，将人们日常生活中能够观察到的现象和基督教的神学联系起来，控制人们的思想，巩固自己的地位。</p>
<p>文艺复兴运动的意义在于，当时有许多游离于教会之外的学者，将这些知识从神学当中剥离开来。它将人们的生活从神圣的教会的光辉中解脱出来，认为宗教只是私人事情的一部分，不应该左右社会，也不应该控制人们的思想。总而言之，它将社会逐渐世俗化。</p>
<p>将知识从教会的手中解放出来本来应当是一件好事。可是，当时的学者认可古希腊的科技知识，向往其时的社会状态，并对此达到了一种狂热的地步。<strong>他们认为古希腊的科技文化知识是经典的、最好的、无与伦比无法超越的。也就是说，他们继承了古希腊的知识，却未能继承古希腊人们辩证的思想。</strong></p>
<p>在文艺复兴运动中，思想得以从教会的控制中解放，然而将古希腊当做是「上限」却又阻碍了欧洲「再进一步」。</p>
<p>事实上，「古典」、「中世纪」和「近代」这样的划分就是文艺复兴时期的观点。那时候人们认为古典世界已然臻至完美，却在中世纪被基督教会掌控逐渐偏离正道，而文艺复兴又重新回到了正轨。古希腊人曾经认为人体是完美的，在艺术上的裸体展现得是人体的力量和美。而中世纪的绘画雕塑则对裸体遮遮掩掩，反映的是基督教的原罪，认为裸体是邪恶的。到了文艺复兴，米开朗琪罗的雕塑作品，当然是裸体塑像，则被认为是尊贵、高尚和美丽的化身。</p>
<p>而反过来，欧洲人至今以基督诞生的那年作为纪年起点。前一种对年代的划分明显排斥基督教，实际的纪元却又与基督教密不可分。</p>
<p>此间的矛盾一方面反映了欧洲继承自「混合体」，另一方面反映出文艺复兴虽然是思想的一次革命，但却不够彻底。</p>
<h2 id=" 宗教改革 ">宗教改革</h2>
<p>前文提到，在进入罗马帝国的几百年间，基督教发展出了庞大而完善的体制；在罗马帝国灭亡之后，教皇与君主平起平坐，管理文武百官。最终的结果就是前文提到的「基督教变成了罗马人的宗教」。</p>
<p>实际上，教会发展到最后，变成了这样一种怪物：教义由教会制定、整个社会也受教会管理、对犯错的人的审判也由教会进行。你没看错，立法权、行政权、司法权都被教会一手掌握。这种畸形的怪物发展到什么地步呢？如果你是一个富商，在你将死的时候，会有神父告诉你，你必须把钱捐出来给教会，不然你就进不了天堂。</p>
<p>马丁·路德是一名虔诚的基督教徒，他对自己的原罪感到无可奈何，对如何救赎毫无头绪，终日煎熬。他不知道自己一个浑身罪恶的人，如何才能得到救赎。有一天，马丁·路德读到《圣经》中保罗写给罗马教会的书信，信中说：「只要你相信耶稣基督，就能得到救赎」。也就是说，你其实什么也不用做，不用遵循教会制定的法度，不用对神父言听计从，只要相信上帝，坚守自己的信仰，就能得到救赎。</p>
<p>马丁·路德认为，《圣经》是唯一的权威：凡是圣经上没有写的，教会就没有理由去制定或者执行哪个「训令」。马丁·路德意识到，人们的思想为教会所控制，根本原因在于《圣经》是由拉丁文所写，并不是人人都能阅读的。于是马丁·路德将《圣经》翻译成德文，使得人人都能从《圣经》中得到自我救赎的力量。</p>
<p>马丁·路德的基督教后来从罗马教会的基督教中分离出来。遵循「因信称义」的观点的马丁·路德教派，后来发展为「基督新教」，而罗马教会的基督教，则被称为「天主教」。</p>
<p>宗教改革的核心观点在于，<strong>《圣经》是唯一的权威，基督教并不是罗马人的，要让基督教回到中世纪之前的样子</strong>。</p>
<p>有意思的是，马丁·路德从天主教那里拿来《圣经》把它翻译出来，变得人人都可以读，人人都可以从中得到自己的见解。于是，原本唯一的、权威的解读不复存在了，各种解读并立而起，马丁·路德自己的解释也被攻击。经过百余年的争吵，谁也无法说服谁，天主教和基督新教慢慢变得和平共处。</p>
<p>文艺复兴和宗教改革在一定意义上都是「回到过去」。文艺复兴从罗马教会那里拿来古希腊和古罗马的文化知识，来对抗教会对知识的钳制；宗教改革则从罗马教会那里拿来圣经，颠覆天主教的神学和权威。接下来 17 世纪的科学革命则整个颠覆了过去人们的观念。</p>
<h2 id=" 科学革命 ">科学革命</h2>
<p>由于观测手段的限制，希腊人认为地球是宇宙的中心——有谁能推动地球呢？17 世纪，这个观点终于被推翻。地球环绕着太阳运行，太阳才是这个天体系统的中心。</p>
<p>首先是观测。随着观测手段的不断进步，人们对星体运行的轨迹描绘得越来越精确。与此同时，这些轨迹与地心说的轨迹误差越来越大，地心说的维护者不得不去不断进行修正，使得地心说的模型变得越来越复杂。其次时理论。牛顿的万有引力定律和相应的数学手段为日心说提供了有力的理论武器。人们精确地计算出了地球绕太阳运转的轨道，与观测事实符合得很好。</p>
<p>这样一来，地心说终于招架不住，教会不得不低头，承认日心说。在科学发展的过程中，人们产生了两种情绪：</p>
<ul>
<li><strong>希腊人错了，古典并不是完美的</strong></li>
<li><strong>自以为特别的我们在宇宙中其实很普通</strong></li>
</ul>
<p>好在，那个时代的人并没有因为日心说、进化论之类的发现而妄自菲薄，贬低自己的重要性。相反，他们认为，如果人们能够借由理性，探索出整个自然体系的运作规律、用数学模型精确表达，再将这些成果反馈到人类生活上，人类就会发生巨大的改变。这种渴望，成为了启蒙运动的原动力。</p>
<h2 id=" 启蒙运动 ">启蒙运动</h2>
<p>启蒙运动于 18 世纪从法国开始，其目的是<strong>弘扬理性，用理性改造神学、政府和社会观念</strong>。</p>
<p>启蒙运动时期的人们认为，当时的法国有两大非理性势力。其一是教会。教会到处宣传神迹故事，控制人们的思想，威胁他们说如果不听话就要去地狱受苦。其二是法国国王。国王说自己是受上帝神谕管理这个国家的，质疑王权就是违反教义。（奉天承运什么的……）</p>
<p>启蒙运动过程中，有一部百科全书被人们汇总出来。它是第一部现代意义上的百科全书。其<strong>将理性运用于一切事物，将神、宗教和其他概念并列于同一个层级</strong>。这传达出一个信息：<strong>宗教是迷信</strong>。</p>
<p>从文艺复兴到宗教改革，从科学革命到启蒙运动，曾经主导欧洲社会的基督教会地位被不断削弱，欧洲走上了理性、进步的道路。</p>
]]></content>
    <summary type="html"><![CDATA[<p><a href="/2014/12/30/history-of-europe-01/">上一次</a>讲到欧洲文明发端的三股力量和古典、中世纪和近代在事件和时间上的划分。今次写一写和思想有关的东西。</p>
<p>上述三股力量组成的混合体经历了长达一千年的中世纪时期。然而，尽管持续时间很长，这个混合体内部却并不稳定。伴随着文艺复兴的开始，从公元 1400 年左右开始，这个混合体逐渐崩毁，并开始建立起新的秩序。</p>
]]></summary>
    
      <category term="History" scheme="http://liam0205.me/tags/History/"/>
    
      <category term="Europe" scheme="http://liam0205.me/tags/Europe/"/>
    
      <category term="Christianity" scheme="http://liam0205.me/tags/Christianity/"/>
    
      <category term="God" scheme="http://liam0205.me/tags/God/"/>
    
      <category term="Reason" scheme="http://liam0205.me/tags/Reason/"/>
    
      <category term="Science" scheme="http://liam0205.me/tags/Science/"/>
    
      <category term="Romantic" scheme="http://liam0205.me/tags/Romantic/"/>
    
      <category term="Literature and Social Sciences" scheme="http://liam0205.me/categories/Literature%20and%20Social%20Sciences/"/>
    
  </entry>
  
</feed>
